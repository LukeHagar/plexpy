"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import date
from enum import Enum
import httpx
from plex_api_client.types import BaseModel
from plex_api_client.utils import FieldMetadata, QueryParamMetadata
import pydantic
from typing import List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class Type(int, Enum):
    r"""The type of media to retrieve or filter by.
    1 = movie
    2 = show
    3 = season
    4 = episode
    E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries

    """

    MOVIE = 1
    TV_SHOW = 2
    SEASON = 3
    EPISODE = 4
    AUDIO = 8
    ALBUM = 9
    TRACK = 10


class IncludeMeta(int, Enum):
    r"""Adds the Meta object to the response"""

    DISABLE = 0
    ENABLE = 1


class GetRecentlyAddedRequestTypedDict(TypedDict):
    content_directory_id: int
    r"""The content directory ID."""
    type: Type
    r"""The type of media to retrieve or filter by.
    1 = movie
    2 = show
    3 = season
    4 = episode
    E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries

    """
    pinned_content_directory_id: NotRequired[str]
    r"""Comma-separated list of pinned content directory IDs."""
    section_id: NotRequired[int]
    r"""The library section ID for filtering content."""
    include_meta: NotRequired[IncludeMeta]
    r"""Adds the Meta object to the response

    """
    x_plex_container_start: NotRequired[int]
    r"""The index of the first item to return. If not specified, the first item will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 0

    """
    x_plex_container_size: NotRequired[int]
    r"""The number of items to return. If not specified, all items will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 50

    """


class GetRecentlyAddedRequest(BaseModel):
    content_directory_id: Annotated[
        int,
        pydantic.Field(alias="contentDirectoryID"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ]
    r"""The content directory ID."""

    type: Annotated[
        Type, FieldMetadata(query=QueryParamMetadata(style="form", explode=True))
    ]
    r"""The type of media to retrieve or filter by.
    1 = movie
    2 = show
    3 = season
    4 = episode
    E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries

    """

    pinned_content_directory_id: Annotated[
        Optional[str],
        pydantic.Field(alias="pinnedContentDirectoryID"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Comma-separated list of pinned content directory IDs."""

    section_id: Annotated[
        Optional[int],
        pydantic.Field(alias="sectionID"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""The library section ID for filtering content."""

    include_meta: Annotated[
        Optional[IncludeMeta],
        pydantic.Field(alias="includeMeta"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = IncludeMeta.DISABLE
    r"""Adds the Meta object to the response

    """

    x_plex_container_start: Annotated[
        Optional[int],
        pydantic.Field(alias="X-Plex-Container-Start"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 0
    r"""The index of the first item to return. If not specified, the first item will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 0

    """

    x_plex_container_size: Annotated[
        Optional[int],
        pydantic.Field(alias="X-Plex-Container-Size"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 50
    r"""The number of items to return. If not specified, all items will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 50

    """


class GetRecentlyAddedFilterTypedDict(TypedDict):
    filter_: str
    filter_type: str
    key: str
    title: str
    type: str
    advanced: NotRequired[bool]


class GetRecentlyAddedFilter(BaseModel):
    filter_: Annotated[str, pydantic.Field(alias="filter")]

    filter_type: Annotated[str, pydantic.Field(alias="filterType")]

    key: str

    title: str

    type: str

    advanced: Optional[bool] = None


class GetRecentlyAddedActiveDirection(str, Enum):
    r"""The direction of the sort. Can be either `asc` or `desc`."""

    ASCENDING = "asc"
    DESCENDING = "desc"


class GetRecentlyAddedDefaultDirection(str, Enum):
    r"""The direction of the sort. Can be either `asc` or `desc`."""

    ASCENDING = "asc"
    DESCENDING = "desc"


class GetRecentlyAddedSortTypedDict(TypedDict):
    key: str
    title: str
    default: NotRequired[str]
    active: NotRequired[bool]
    active_direction: NotRequired[GetRecentlyAddedActiveDirection]
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """
    default_direction: NotRequired[GetRecentlyAddedDefaultDirection]
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """
    desc_key: NotRequired[str]
    first_character_key: NotRequired[str]


class GetRecentlyAddedSort(BaseModel):
    key: str

    title: str

    default: Optional[str] = None

    active: Optional[bool] = None

    active_direction: Annotated[
        Optional[GetRecentlyAddedActiveDirection],
        pydantic.Field(alias="activeDirection"),
    ] = GetRecentlyAddedActiveDirection.ASCENDING
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """

    default_direction: Annotated[
        Optional[GetRecentlyAddedDefaultDirection],
        pydantic.Field(alias="defaultDirection"),
    ] = GetRecentlyAddedDefaultDirection.ASCENDING
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """

    desc_key: Annotated[Optional[str], pydantic.Field(alias="descKey")] = None

    first_character_key: Annotated[
        Optional[str], pydantic.Field(alias="firstCharacterKey")
    ] = None


class GetRecentlyAddedFieldTypedDict(TypedDict):
    key: str
    title: str
    type: str
    sub_type: NotRequired[str]


class GetRecentlyAddedField(BaseModel):
    key: str

    title: str

    type: str

    sub_type: Annotated[Optional[str], pydantic.Field(alias="subType")] = None


class GetRecentlyAddedTypeTypedDict(TypedDict):
    key: str
    type: str
    title: str
    active: bool
    subtype: NotRequired[str]
    filter_: NotRequired[List[GetRecentlyAddedFilterTypedDict]]
    sort: NotRequired[List[GetRecentlyAddedSortTypedDict]]
    field: NotRequired[List[GetRecentlyAddedFieldTypedDict]]


class GetRecentlyAddedType(BaseModel):
    key: str

    type: str

    title: str

    active: bool

    subtype: Optional[str] = None

    filter_: Annotated[
        Optional[List[GetRecentlyAddedFilter]], pydantic.Field(alias="Filter")
    ] = None

    sort: Annotated[
        Optional[List[GetRecentlyAddedSort]], pydantic.Field(alias="Sort")
    ] = None

    field: Annotated[
        Optional[List[GetRecentlyAddedField]], pydantic.Field(alias="Field")
    ] = None


class GetRecentlyAddedOperatorTypedDict(TypedDict):
    key: str
    title: str


class GetRecentlyAddedOperator(BaseModel):
    key: str

    title: str


class GetRecentlyAddedFieldTypeTypedDict(TypedDict):
    type: str
    operator: List[GetRecentlyAddedOperatorTypedDict]


class GetRecentlyAddedFieldType(BaseModel):
    type: str

    operator: Annotated[
        List[GetRecentlyAddedOperator], pydantic.Field(alias="Operator")
    ]


class MetaTypedDict(TypedDict):
    r"""The Meta object is only included in the response if the `includeMeta` parameter is set to `1`."""

    type: NotRequired[List[GetRecentlyAddedTypeTypedDict]]
    field_type: NotRequired[List[GetRecentlyAddedFieldTypeTypedDict]]


class Meta(BaseModel):
    r"""The Meta object is only included in the response if the `includeMeta` parameter is set to `1`."""

    type: Annotated[
        Optional[List[GetRecentlyAddedType]], pydantic.Field(alias="Type")
    ] = None

    field_type: Annotated[
        Optional[List[GetRecentlyAddedFieldType]], pydantic.Field(alias="FieldType")
    ] = None


class GetRecentlyAddedHubsType(str, Enum):
    r"""The type of media content"""

    MOVIE = "movie"
    TV_SHOW = "show"
    SEASON = "season"
    EPISODE = "episode"
    ARTIST = "artist"
    ALBUM = "album"


class GetRecentlyAddedHubsResponseType(str, Enum):
    COVER_POSTER = "coverPoster"
    BACKGROUND = "background"
    SNAPSHOT = "snapshot"
    CLEAR_LOGO = "clearLogo"


class GetRecentlyAddedImageTypedDict(TypedDict):
    alt: str
    type: GetRecentlyAddedHubsResponseType
    url: str


class GetRecentlyAddedImage(BaseModel):
    alt: str

    type: GetRecentlyAddedHubsResponseType

    url: str


class UltraBlurColorsTypedDict(TypedDict):
    top_left: str
    top_right: str
    bottom_right: str
    bottom_left: str


class UltraBlurColors(BaseModel):
    top_left: Annotated[str, pydantic.Field(alias="topLeft")]

    top_right: Annotated[str, pydantic.Field(alias="topRight")]

    bottom_right: Annotated[str, pydantic.Field(alias="bottomRight")]

    bottom_left: Annotated[str, pydantic.Field(alias="bottomLeft")]


class One(int, Enum):
    ZERO = 0
    ONE = 1


OptimizedForStreamingTypedDict = TypeAliasType(
    "OptimizedForStreamingTypedDict", Union[One, bool]
)
r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""


OptimizedForStreaming = TypeAliasType("OptimizedForStreaming", Union[One, bool])
r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""


class GetRecentlyAddedOptimizedForStreaming1(int, Enum):
    ZERO = 0
    ONE = 1


GetRecentlyAddedOptimizedForStreamingTypedDict = TypeAliasType(
    "GetRecentlyAddedOptimizedForStreamingTypedDict",
    Union[GetRecentlyAddedOptimizedForStreaming1, bool],
)
r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""


GetRecentlyAddedOptimizedForStreaming = TypeAliasType(
    "GetRecentlyAddedOptimizedForStreaming",
    Union[GetRecentlyAddedOptimizedForStreaming1, bool],
)
r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""


class HasThumbnail(str, Enum):
    r"""Indicates if the part has a thumbnail."""

    FALSE = "0"
    TRUE = "1"


class StreamTypedDict(TypedDict):
    id: int
    r"""Unique stream identifier."""
    stream_type: int
    r"""Stream type (1=video, 2=audio, 3=subtitle)."""
    codec: str
    r"""Codec used by the stream."""
    index: int
    r"""Index of the stream."""
    display_title: str
    r"""Display title for the stream."""
    extended_display_title: str
    r"""Extended display title for the stream."""
    default: NotRequired[bool]
    r"""Indicates if this stream is default."""
    bitrate: NotRequired[int]
    r"""Bitrate of the stream."""
    language: NotRequired[str]
    r"""Language of the stream."""
    language_tag: NotRequired[str]
    r"""Language tag (e.g., en)."""
    language_code: NotRequired[str]
    r"""ISO language code."""
    header_compression: NotRequired[bool]
    r"""Indicates whether header compression is enabled."""
    dovibl_compat_id: NotRequired[int]
    r"""Dolby Vision BL compatibility ID."""
    dovibl_present: NotRequired[bool]
    r"""Indicates if Dolby Vision BL is present."""
    doviel_present: NotRequired[bool]
    r"""Indicates if Dolby Vision EL is present."""
    dovi_level: NotRequired[int]
    r"""Dolby Vision level."""
    dovi_present: NotRequired[bool]
    r"""Indicates if Dolby Vision is present."""
    dovi_profile: NotRequired[int]
    r"""Dolby Vision profile."""
    dovirpu_present: NotRequired[bool]
    r"""Indicates if Dolby Vision RPU is present."""
    dovi_version: NotRequired[str]
    r"""Dolby Vision version."""
    bit_depth: NotRequired[int]
    r"""Bit depth of the video stream."""
    chroma_location: NotRequired[str]
    r"""Chroma sample location."""
    chroma_subsampling: NotRequired[str]
    r"""Chroma subsampling format."""
    coded_height: NotRequired[int]
    r"""Coded video height."""
    coded_width: NotRequired[int]
    r"""Coded video width."""
    closed_captions: NotRequired[bool]
    color_primaries: NotRequired[str]
    r"""Color primaries used."""
    color_range: NotRequired[str]
    r"""Color range (e.g., tv)."""
    color_space: NotRequired[str]
    r"""Color space."""
    color_trc: NotRequired[str]
    r"""Color transfer characteristics."""
    frame_rate: NotRequired[float]
    r"""Frame rate of the stream."""
    height: NotRequired[int]
    r"""Height of the video stream."""
    level: NotRequired[int]
    r"""Video level."""
    original: NotRequired[bool]
    r"""Indicates if this is the original stream."""
    has_scaling_matrix: NotRequired[bool]
    profile: NotRequired[str]
    r"""Video profile."""
    scan_type: NotRequired[str]
    embedded_in_video: NotRequired[str]
    ref_frames: NotRequired[int]
    r"""Number of reference frames."""
    width: NotRequired[int]
    r"""Width of the video stream."""
    selected: NotRequired[bool]
    r"""Indicates if this stream is selected (applicable for audio streams)."""
    forced: NotRequired[bool]
    channels: NotRequired[int]
    r"""Number of audio channels (for audio streams)."""
    audio_channel_layout: NotRequired[str]
    r"""Audio channel layout."""
    sampling_rate: NotRequired[int]
    r"""Sampling rate for the audio stream."""
    can_auto_sync: NotRequired[bool]
    r"""Indicates if the stream can auto-sync."""
    hearing_impaired: NotRequired[bool]
    r"""Indicates if the stream is for the hearing impaired."""
    dub: NotRequired[bool]
    r"""Indicates if the stream is a dub."""
    title: NotRequired[str]
    r"""Optional title for the stream (e.g., language variant)."""


class Stream(BaseModel):
    id: int
    r"""Unique stream identifier."""

    stream_type: Annotated[int, pydantic.Field(alias="streamType")]
    r"""Stream type (1=video, 2=audio, 3=subtitle)."""

    codec: str
    r"""Codec used by the stream."""

    index: int
    r"""Index of the stream."""

    display_title: Annotated[str, pydantic.Field(alias="displayTitle")]
    r"""Display title for the stream."""

    extended_display_title: Annotated[str, pydantic.Field(alias="extendedDisplayTitle")]
    r"""Extended display title for the stream."""

    default: Optional[bool] = None
    r"""Indicates if this stream is default."""

    bitrate: Optional[int] = None
    r"""Bitrate of the stream."""

    language: Optional[str] = None
    r"""Language of the stream."""

    language_tag: Annotated[Optional[str], pydantic.Field(alias="languageTag")] = None
    r"""Language tag (e.g., en)."""

    language_code: Annotated[Optional[str], pydantic.Field(alias="languageCode")] = None
    r"""ISO language code."""

    header_compression: Annotated[
        Optional[bool], pydantic.Field(alias="headerCompression")
    ] = None
    r"""Indicates whether header compression is enabled."""

    dovibl_compat_id: Annotated[
        Optional[int], pydantic.Field(alias="DOVIBLCompatID")
    ] = None
    r"""Dolby Vision BL compatibility ID."""

    dovibl_present: Annotated[Optional[bool], pydantic.Field(alias="DOVIBLPresent")] = (
        None
    )
    r"""Indicates if Dolby Vision BL is present."""

    doviel_present: Annotated[Optional[bool], pydantic.Field(alias="DOVIELPresent")] = (
        None
    )
    r"""Indicates if Dolby Vision EL is present."""

    dovi_level: Annotated[Optional[int], pydantic.Field(alias="DOVILevel")] = None
    r"""Dolby Vision level."""

    dovi_present: Annotated[Optional[bool], pydantic.Field(alias="DOVIPresent")] = None
    r"""Indicates if Dolby Vision is present."""

    dovi_profile: Annotated[Optional[int], pydantic.Field(alias="DOVIProfile")] = None
    r"""Dolby Vision profile."""

    dovirpu_present: Annotated[
        Optional[bool], pydantic.Field(alias="DOVIRPUPresent")
    ] = None
    r"""Indicates if Dolby Vision RPU is present."""

    dovi_version: Annotated[Optional[str], pydantic.Field(alias="DOVIVersion")] = None
    r"""Dolby Vision version."""

    bit_depth: Annotated[Optional[int], pydantic.Field(alias="bitDepth")] = None
    r"""Bit depth of the video stream."""

    chroma_location: Annotated[
        Optional[str], pydantic.Field(alias="chromaLocation")
    ] = None
    r"""Chroma sample location."""

    chroma_subsampling: Annotated[
        Optional[str], pydantic.Field(alias="chromaSubsampling")
    ] = None
    r"""Chroma subsampling format."""

    coded_height: Annotated[Optional[int], pydantic.Field(alias="codedHeight")] = None
    r"""Coded video height."""

    coded_width: Annotated[Optional[int], pydantic.Field(alias="codedWidth")] = None
    r"""Coded video width."""

    closed_captions: Annotated[
        Optional[bool], pydantic.Field(alias="closedCaptions")
    ] = None

    color_primaries: Annotated[
        Optional[str], pydantic.Field(alias="colorPrimaries")
    ] = None
    r"""Color primaries used."""

    color_range: Annotated[Optional[str], pydantic.Field(alias="colorRange")] = None
    r"""Color range (e.g., tv)."""

    color_space: Annotated[Optional[str], pydantic.Field(alias="colorSpace")] = None
    r"""Color space."""

    color_trc: Annotated[Optional[str], pydantic.Field(alias="colorTrc")] = None
    r"""Color transfer characteristics."""

    frame_rate: Annotated[Optional[float], pydantic.Field(alias="frameRate")] = None
    r"""Frame rate of the stream."""

    height: Optional[int] = None
    r"""Height of the video stream."""

    level: Optional[int] = None
    r"""Video level."""

    original: Optional[bool] = None
    r"""Indicates if this is the original stream."""

    has_scaling_matrix: Annotated[
        Optional[bool], pydantic.Field(alias="hasScalingMatrix")
    ] = None

    profile: Optional[str] = None
    r"""Video profile."""

    scan_type: Annotated[Optional[str], pydantic.Field(alias="scanType")] = None

    embedded_in_video: Annotated[
        Optional[str], pydantic.Field(alias="embeddedInVideo")
    ] = None

    ref_frames: Annotated[Optional[int], pydantic.Field(alias="refFrames")] = None
    r"""Number of reference frames."""

    width: Optional[int] = None
    r"""Width of the video stream."""

    selected: Optional[bool] = None
    r"""Indicates if this stream is selected (applicable for audio streams)."""

    forced: Optional[bool] = None

    channels: Optional[int] = None
    r"""Number of audio channels (for audio streams)."""

    audio_channel_layout: Annotated[
        Optional[str], pydantic.Field(alias="audioChannelLayout")
    ] = None
    r"""Audio channel layout."""

    sampling_rate: Annotated[Optional[int], pydantic.Field(alias="samplingRate")] = None
    r"""Sampling rate for the audio stream."""

    can_auto_sync: Annotated[Optional[bool], pydantic.Field(alias="canAutoSync")] = None
    r"""Indicates if the stream can auto-sync."""

    hearing_impaired: Annotated[
        Optional[bool], pydantic.Field(alias="hearingImpaired")
    ] = None
    r"""Indicates if the stream is for the hearing impaired."""

    dub: Optional[bool] = None
    r"""Indicates if the stream is a dub."""

    title: Optional[str] = None
    r"""Optional title for the stream (e.g., language variant)."""


class PartTypedDict(TypedDict):
    id: int
    r"""Unique part identifier."""
    key: str
    r"""Key to access this part."""
    file: str
    r"""File path for the part."""
    size: int
    r"""File size in bytes."""
    accessible: NotRequired[bool]
    r"""Indicates if the part is accessible."""
    exists: NotRequired[bool]
    r"""Indicates if the part exists."""
    indexes: NotRequired[str]
    duration: NotRequired[int]
    r"""Duration of the part in milliseconds."""
    packet_length: NotRequired[int]
    container: NotRequired[str]
    r"""Container format of the part."""
    video_profile: NotRequired[str]
    r"""Video profile for the part."""
    audio_profile: NotRequired[str]
    r"""The audio profile used for the media (e.g., DTS, Dolby Digital, etc.)."""
    has64bit_offsets: NotRequired[bool]
    optimized_for_streaming: NotRequired[GetRecentlyAddedOptimizedForStreamingTypedDict]
    r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""
    has_thumbnail: NotRequired[HasThumbnail]
    stream: NotRequired[List[StreamTypedDict]]
    r"""An array of streams for this part."""


class Part(BaseModel):
    id: int
    r"""Unique part identifier."""

    key: str
    r"""Key to access this part."""

    file: str
    r"""File path for the part."""

    size: int
    r"""File size in bytes."""

    accessible: Optional[bool] = None
    r"""Indicates if the part is accessible."""

    exists: Optional[bool] = None
    r"""Indicates if the part exists."""

    indexes: Optional[str] = None

    duration: Optional[int] = None
    r"""Duration of the part in milliseconds."""

    packet_length: Annotated[Optional[int], pydantic.Field(alias="packetLength")] = None

    container: Optional[str] = None
    r"""Container format of the part."""

    video_profile: Annotated[Optional[str], pydantic.Field(alias="videoProfile")] = None
    r"""Video profile for the part."""

    audio_profile: Annotated[Optional[str], pydantic.Field(alias="audioProfile")] = None
    r"""The audio profile used for the media (e.g., DTS, Dolby Digital, etc.)."""

    has64bit_offsets: Annotated[
        Optional[bool], pydantic.Field(alias="has64bitOffsets")
    ] = None

    optimized_for_streaming: Annotated[
        Optional[GetRecentlyAddedOptimizedForStreaming],
        pydantic.Field(alias="optimizedForStreaming"),
    ] = None
    r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""

    has_thumbnail: Annotated[
        Optional[HasThumbnail], pydantic.Field(alias="hasThumbnail")
    ] = HasThumbnail.FALSE

    stream: Annotated[Optional[List[Stream]], pydantic.Field(alias="Stream")] = None
    r"""An array of streams for this part."""


class MediaTypedDict(TypedDict):
    id: int
    r"""Unique media identifier."""
    duration: NotRequired[int]
    r"""Duration of the media in milliseconds."""
    bitrate: NotRequired[int]
    r"""Bitrate in bits per second."""
    width: NotRequired[int]
    r"""Video width in pixels."""
    height: NotRequired[int]
    r"""Video height in pixels."""
    aspect_ratio: NotRequired[float]
    r"""Aspect ratio of the video."""
    audio_channels: NotRequired[int]
    r"""Number of audio channels."""
    display_offset: NotRequired[int]
    audio_codec: NotRequired[str]
    r"""Audio codec used."""
    video_codec: NotRequired[str]
    r"""Video codec used."""
    video_resolution: NotRequired[str]
    r"""Video resolution (e.g., 4k)."""
    container: NotRequired[str]
    r"""File container type."""
    video_frame_rate: NotRequired[str]
    r"""Frame rate of the video. Values found include NTSC, PAL, 24p

    """
    video_profile: NotRequired[str]
    r"""Video profile (e.g., main 10)."""
    has_voice_activity: NotRequired[bool]
    r"""Indicates whether voice activity is detected."""
    audio_profile: NotRequired[str]
    r"""The audio profile used for the media (e.g., DTS, Dolby Digital, etc.)."""
    optimized_for_streaming: NotRequired[OptimizedForStreamingTypedDict]
    r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""
    has64bit_offsets: NotRequired[bool]
    part: NotRequired[List[PartTypedDict]]
    r"""An array of parts for this media item."""


class Media(BaseModel):
    id: int
    r"""Unique media identifier."""

    duration: Optional[int] = None
    r"""Duration of the media in milliseconds."""

    bitrate: Optional[int] = None
    r"""Bitrate in bits per second."""

    width: Optional[int] = None
    r"""Video width in pixels."""

    height: Optional[int] = None
    r"""Video height in pixels."""

    aspect_ratio: Annotated[Optional[float], pydantic.Field(alias="aspectRatio")] = None
    r"""Aspect ratio of the video."""

    audio_channels: Annotated[Optional[int], pydantic.Field(alias="audioChannels")] = (
        None
    )
    r"""Number of audio channels."""

    display_offset: Annotated[Optional[int], pydantic.Field(alias="displayOffset")] = (
        None
    )

    audio_codec: Annotated[Optional[str], pydantic.Field(alias="audioCodec")] = None
    r"""Audio codec used."""

    video_codec: Annotated[Optional[str], pydantic.Field(alias="videoCodec")] = None
    r"""Video codec used."""

    video_resolution: Annotated[
        Optional[str], pydantic.Field(alias="videoResolution")
    ] = None
    r"""Video resolution (e.g., 4k)."""

    container: Optional[str] = None
    r"""File container type."""

    video_frame_rate: Annotated[
        Optional[str], pydantic.Field(alias="videoFrameRate")
    ] = None
    r"""Frame rate of the video. Values found include NTSC, PAL, 24p

    """

    video_profile: Annotated[Optional[str], pydantic.Field(alias="videoProfile")] = None
    r"""Video profile (e.g., main 10)."""

    has_voice_activity: Annotated[
        Optional[bool], pydantic.Field(alias="hasVoiceActivity")
    ] = None
    r"""Indicates whether voice activity is detected."""

    audio_profile: Annotated[Optional[str], pydantic.Field(alias="audioProfile")] = None
    r"""The audio profile used for the media (e.g., DTS, Dolby Digital, etc.)."""

    optimized_for_streaming: Annotated[
        Optional[OptimizedForStreaming], pydantic.Field(alias="optimizedForStreaming")
    ] = None
    r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""

    has64bit_offsets: Annotated[
        Optional[bool], pydantic.Field(alias="has64bitOffsets")
    ] = None

    part: Annotated[Optional[List[Part]], pydantic.Field(alias="Part")] = None
    r"""An array of parts for this media item."""


class GenreTypedDict(TypedDict):
    r"""The filter query string for similar items."""

    id: int
    filter_: str
    tag: str
    r"""The genre name of this media-item

    """


class Genre(BaseModel):
    r"""The filter query string for similar items."""

    id: int

    filter_: Annotated[str, pydantic.Field(alias="filter")]

    tag: str
    r"""The genre name of this media-item

    """


class CountryTypedDict(TypedDict):
    r"""The filter query string for country media items."""

    id: int
    tag: str
    r"""The country of origin of this media item"""
    filter_: NotRequired[str]


class Country(BaseModel):
    r"""The filter query string for country media items."""

    id: int

    tag: str
    r"""The country of origin of this media item"""

    filter_: Annotated[Optional[str], pydantic.Field(alias="filter")] = None


class DirectorTypedDict(TypedDict):
    tag: str
    r"""The role of Director"""


class Director(BaseModel):
    tag: str
    r"""The role of Director"""


class WriterTypedDict(TypedDict):
    id: int
    r"""Unique identifier for the writer."""
    filter_: str
    r"""The filter string used to query this writer."""
    tag: str
    r"""The role of Writer"""
    tag_key: NotRequired[str]
    r"""A unique key associated with the writers tag, used for internal identification."""


class Writer(BaseModel):
    id: int
    r"""Unique identifier for the writer."""

    filter_: Annotated[str, pydantic.Field(alias="filter")]
    r"""The filter string used to query this writer."""

    tag: str
    r"""The role of Writer"""

    tag_key: Annotated[Optional[str], pydantic.Field(alias="tagKey")] = None
    r"""A unique key associated with the writers tag, used for internal identification."""


class RoleTypedDict(TypedDict):
    id: int
    r"""Unique identifier for the actor or role."""
    filter_: str
    r"""The filter string used to query this actor. For example, it may indicate that this is an actor with a given key."""
    tag: str
    r"""The display tag for the actor (typically the actor's name)."""
    tag_key: NotRequired[str]
    r"""A unique key associated with the actor's tag, used for internal identification."""
    role: NotRequired[str]
    r"""The role played by the actor in the media item."""
    thumb: NotRequired[str]
    r"""The URL of the thumbnail image for the actor."""


class Role(BaseModel):
    id: int
    r"""Unique identifier for the actor or role."""

    filter_: Annotated[str, pydantic.Field(alias="filter")]
    r"""The filter string used to query this actor. For example, it may indicate that this is an actor with a given key."""

    tag: str
    r"""The display tag for the actor (typically the actor's name)."""

    tag_key: Annotated[Optional[str], pydantic.Field(alias="tagKey")] = None
    r"""A unique key associated with the actor's tag, used for internal identification."""

    role: Optional[str] = None
    r"""The role played by the actor in the media item."""

    thumb: Optional[str] = None
    r"""The URL of the thumbnail image for the actor."""


class ProducerTypedDict(TypedDict):
    id: int
    r"""Unique identifier for the producer."""
    filter_: str
    r"""The filter string used to query this producer."""
    tag: str
    r"""The name of the producer"""
    tag_key: NotRequired[str]
    r"""A unique key associated with the producer's tag, used for internal identification."""
    thumb: NotRequired[str]
    r"""The URL of the thumbnail image for the actor."""


class Producer(BaseModel):
    id: int
    r"""Unique identifier for the producer."""

    filter_: Annotated[str, pydantic.Field(alias="filter")]
    r"""The filter string used to query this producer."""

    tag: str
    r"""The name of the producer"""

    tag_key: Annotated[Optional[str], pydantic.Field(alias="tagKey")] = None
    r"""A unique key associated with the producer's tag, used for internal identification."""

    thumb: Optional[str] = None
    r"""The URL of the thumbnail image for the actor."""


class RatingTypedDict(TypedDict):
    r"""The type of rating, for example 'audience' or 'critic'."""

    image: str
    value: float
    type: str


class Rating(BaseModel):
    r"""The type of rating, for example 'audience' or 'critic'."""

    image: str

    value: float

    type: str


class SimilarTypedDict(TypedDict):
    r"""The display tag for the similar item, typically the title."""

    id: int
    filter_: str
    tag: str


class Similar(BaseModel):
    r"""The display tag for the similar item, typically the title."""

    id: int

    filter_: Annotated[str, pydantic.Field(alias="filter")]

    tag: str


class LocationTypedDict(TypedDict):
    r"""The folder path for the media item."""

    path: str


class Location(BaseModel):
    r"""The folder path for the media item."""

    path: str


class GuidsTypedDict(TypedDict):
    id: NotRequired[str]
    r"""The unique identifier for the Guid. Can be imdb://tt0286347, tmdb://1763, tvdb://2337

    """


class Guids(BaseModel):
    id: Optional[str] = None
    r"""The unique identifier for the Guid. Can be imdb://tt0286347, tmdb://1763, tvdb://2337

    """


class CollectionTypedDict(TypedDict):
    tag: str
    r"""The user-made collection this media item belongs to"""


class Collection(BaseModel):
    tag: str
    r"""The user-made collection this media item belongs to"""


class GetRecentlyAddedMetadataTypedDict(TypedDict):
    r"""Unknown"""

    added_at: int
    art: str
    r"""The art image URL for the media item."""
    audience_rating: float
    r"""The audience rating for the media item."""
    child_count: int
    r"""The number of child items associated with this media item."""
    duration: int
    r"""The duration of the media item in milliseconds."""
    guid: str
    r"""The globally unique identifier for the media item."""
    index: int
    r"""The index position of the media item."""
    key: str
    r"""The unique key for the media item."""
    library_section_id: int
    r"""The identifier for the library section."""
    library_section_key: str
    r"""The key corresponding to the library section."""
    library_section_title: str
    r"""The title of the library section."""
    originally_available_at: date
    r"""The original release date of the media item."""
    parent_studio: str
    r"""The studio of the parent media item."""
    parent_theme: str
    r"""The theme URL for the parent media item."""
    rating_key: str
    r"""The rating key (Media ID) of this media item. Note: Although this is always an integer, it is represented as a string in the API."""
    rating: float
    r"""The critic rating for the media item."""
    season_count: int
    r"""The total number of seasons (for TV shows)."""
    slug: str
    r"""A URL‐friendly version of the media title."""
    summary: str
    r"""A synopsis of the media item."""
    tagline: str
    r"""A brief tagline for the media item."""
    theme: str
    r"""The theme URL for the media item."""
    thumb: str
    r"""The thumbnail image URL for the media item."""
    title_sort: str
    r"""The sort title used for ordering media items."""
    title: str
    r"""The title of the media item."""
    type: GetRecentlyAddedHubsType
    audience_rating_image: NotRequired[str]
    r"""The URL for the audience rating image."""
    chapter_source: NotRequired[str]
    r"""The source from which chapter data is derived."""
    content_rating: NotRequired[str]
    r"""The content rating for the media item."""
    created_at_accuracy: NotRequired[str]
    r"""The accuracy of the creation timestamp. This value indicates the format(s) provided (for example, 'epoch,local' means both epoch and local time formats are available)."""
    created_at_tz_offset: NotRequired[str]
    r"""The time zone offset for the creation timestamp, represented as a string. This offset indicates the difference from UTC."""
    grandparent_art: NotRequired[str]
    r"""The art URL for the grandparent media item."""
    grandparent_guid: NotRequired[str]
    r"""The GUID of the grandparent media item."""
    grandparent_key: NotRequired[str]
    r"""The key of the grandparent media item."""
    grandparent_rating_key: NotRequired[str]
    r"""The rating key of the grandparent media item."""
    grandparent_slug: NotRequired[str]
    r"""The slug for the grandparent media item."""
    grandparent_theme: NotRequired[str]
    r"""The theme URL for the grandparent media item."""
    grandparent_thumb: NotRequired[str]
    r"""The thumbnail URL for the grandparent media item."""
    grandparent_title: NotRequired[str]
    r"""The title of the grandparent media item."""
    last_rated_at: NotRequired[int]
    r"""The Unix timestamp representing the last time the item was rated."""
    last_viewed_at: NotRequired[int]
    r"""Unix timestamp for when the media item was last viewed."""
    leaf_count: NotRequired[int]
    r"""The number of leaf items (end nodes) under this media item."""
    original_title: NotRequired[str]
    r"""The original title of the media item (if different)."""
    parent_guid: NotRequired[str]
    r"""The GUID of the parent media item."""
    parent_index: NotRequired[int]
    r"""The index position of the parent media item."""
    parent_key: NotRequired[str]
    r"""The key of the parent media item."""
    parent_rating_key: NotRequired[str]
    r"""The rating key of the parent media item."""
    parent_slug: NotRequired[str]
    r"""The slug for the parent media item."""
    parent_thumb: NotRequired[str]
    r"""The thumbnail URL for the parent media item."""
    parent_title: NotRequired[str]
    r"""The title of the parent media item."""
    parent_year: NotRequired[int]
    r"""The release year of the parent media item."""
    primary_extra_key: NotRequired[str]
    r"""The primary extra key associated with this media item."""
    rating_image: NotRequired[str]
    r"""The URL for the rating image."""
    skip_count: NotRequired[int]
    r"""The number of times this media item has been skipped."""
    studio: NotRequired[str]
    r"""The studio that produced the media item."""
    subtype: NotRequired[str]
    r"""A classification that further describes the type of media item. For example, 'clip' indicates that the item is a short video clip."""
    updated_at: NotRequired[int]
    r"""Unix epoch datetime in seconds"""
    user_rating: NotRequired[float]
    r"""The rating provided by a user for the item. This value is expressed as a decimal number."""
    view_count: NotRequired[int]
    r"""The number of times this media item has been viewed."""
    view_offset: NotRequired[int]
    r"""The current playback offset (in milliseconds)."""
    viewed_leaf_count: NotRequired[int]
    r"""The number of leaf items that have been viewed."""
    year: NotRequired[int]
    r"""The release year of the media item."""
    image: NotRequired[List[GetRecentlyAddedImageTypedDict]]
    ultra_blur_colors: NotRequired[UltraBlurColorsTypedDict]
    media: NotRequired[List[MediaTypedDict]]
    genre: NotRequired[List[GenreTypedDict]]
    country: NotRequired[List[CountryTypedDict]]
    director: NotRequired[List[DirectorTypedDict]]
    writer: NotRequired[List[WriterTypedDict]]
    role: NotRequired[List[RoleTypedDict]]
    producer: NotRequired[List[ProducerTypedDict]]
    rating1: NotRequired[List[RatingTypedDict]]
    similar: NotRequired[List[SimilarTypedDict]]
    location: NotRequired[List[LocationTypedDict]]
    guids: NotRequired[List[GuidsTypedDict]]
    collection: NotRequired[List[CollectionTypedDict]]


class GetRecentlyAddedMetadata(BaseModel):
    r"""Unknown"""

    added_at: Annotated[int, pydantic.Field(alias="addedAt")]

    art: str
    r"""The art image URL for the media item."""

    audience_rating: Annotated[float, pydantic.Field(alias="audienceRating")]
    r"""The audience rating for the media item."""

    child_count: Annotated[int, pydantic.Field(alias="childCount")]
    r"""The number of child items associated with this media item."""

    duration: int
    r"""The duration of the media item in milliseconds."""

    guid: str
    r"""The globally unique identifier for the media item."""

    index: int
    r"""The index position of the media item."""

    key: str
    r"""The unique key for the media item."""

    library_section_id: Annotated[int, pydantic.Field(alias="librarySectionID")]
    r"""The identifier for the library section."""

    library_section_key: Annotated[str, pydantic.Field(alias="librarySectionKey")]
    r"""The key corresponding to the library section."""

    library_section_title: Annotated[str, pydantic.Field(alias="librarySectionTitle")]
    r"""The title of the library section."""

    originally_available_at: Annotated[
        date, pydantic.Field(alias="originallyAvailableAt")
    ]
    r"""The original release date of the media item."""

    parent_studio: Annotated[str, pydantic.Field(alias="parentStudio")]
    r"""The studio of the parent media item."""

    parent_theme: Annotated[str, pydantic.Field(alias="parentTheme")]
    r"""The theme URL for the parent media item."""

    rating_key: Annotated[str, pydantic.Field(alias="ratingKey")]
    r"""The rating key (Media ID) of this media item. Note: Although this is always an integer, it is represented as a string in the API."""

    rating: float
    r"""The critic rating for the media item."""

    season_count: Annotated[int, pydantic.Field(alias="seasonCount")]
    r"""The total number of seasons (for TV shows)."""

    slug: str
    r"""A URL‐friendly version of the media title."""

    summary: str
    r"""A synopsis of the media item."""

    tagline: str
    r"""A brief tagline for the media item."""

    theme: str
    r"""The theme URL for the media item."""

    thumb: str
    r"""The thumbnail image URL for the media item."""

    title_sort: Annotated[str, pydantic.Field(alias="titleSort")]
    r"""The sort title used for ordering media items."""

    title: str
    r"""The title of the media item."""

    type: GetRecentlyAddedHubsType

    audience_rating_image: Annotated[
        Optional[str], pydantic.Field(alias="audienceRatingImage")
    ] = None
    r"""The URL for the audience rating image."""

    chapter_source: Annotated[Optional[str], pydantic.Field(alias="chapterSource")] = (
        None
    )
    r"""The source from which chapter data is derived."""

    content_rating: Annotated[Optional[str], pydantic.Field(alias="contentRating")] = (
        None
    )
    r"""The content rating for the media item."""

    created_at_accuracy: Annotated[
        Optional[str], pydantic.Field(alias="createdAtAccuracy")
    ] = None
    r"""The accuracy of the creation timestamp. This value indicates the format(s) provided (for example, 'epoch,local' means both epoch and local time formats are available)."""

    created_at_tz_offset: Annotated[
        Optional[str], pydantic.Field(alias="createdAtTZOffset")
    ] = None
    r"""The time zone offset for the creation timestamp, represented as a string. This offset indicates the difference from UTC."""

    grandparent_art: Annotated[
        Optional[str], pydantic.Field(alias="grandparentArt")
    ] = None
    r"""The art URL for the grandparent media item."""

    grandparent_guid: Annotated[
        Optional[str], pydantic.Field(alias="grandparentGuid")
    ] = None
    r"""The GUID of the grandparent media item."""

    grandparent_key: Annotated[
        Optional[str], pydantic.Field(alias="grandparentKey")
    ] = None
    r"""The key of the grandparent media item."""

    grandparent_rating_key: Annotated[
        Optional[str], pydantic.Field(alias="grandparentRatingKey")
    ] = None
    r"""The rating key of the grandparent media item."""

    grandparent_slug: Annotated[
        Optional[str], pydantic.Field(alias="grandparentSlug")
    ] = None
    r"""The slug for the grandparent media item."""

    grandparent_theme: Annotated[
        Optional[str], pydantic.Field(alias="grandparentTheme")
    ] = None
    r"""The theme URL for the grandparent media item."""

    grandparent_thumb: Annotated[
        Optional[str], pydantic.Field(alias="grandparentThumb")
    ] = None
    r"""The thumbnail URL for the grandparent media item."""

    grandparent_title: Annotated[
        Optional[str], pydantic.Field(alias="grandparentTitle")
    ] = None
    r"""The title of the grandparent media item."""

    last_rated_at: Annotated[Optional[int], pydantic.Field(alias="lastRatedAt")] = None
    r"""The Unix timestamp representing the last time the item was rated."""

    last_viewed_at: Annotated[Optional[int], pydantic.Field(alias="lastViewedAt")] = (
        None
    )
    r"""Unix timestamp for when the media item was last viewed."""

    leaf_count: Annotated[Optional[int], pydantic.Field(alias="leafCount")] = None
    r"""The number of leaf items (end nodes) under this media item."""

    original_title: Annotated[Optional[str], pydantic.Field(alias="originalTitle")] = (
        None
    )
    r"""The original title of the media item (if different)."""

    parent_guid: Annotated[Optional[str], pydantic.Field(alias="parentGuid")] = None
    r"""The GUID of the parent media item."""

    parent_index: Annotated[Optional[int], pydantic.Field(alias="parentIndex")] = None
    r"""The index position of the parent media item."""

    parent_key: Annotated[Optional[str], pydantic.Field(alias="parentKey")] = None
    r"""The key of the parent media item."""

    parent_rating_key: Annotated[
        Optional[str], pydantic.Field(alias="parentRatingKey")
    ] = None
    r"""The rating key of the parent media item."""

    parent_slug: Annotated[Optional[str], pydantic.Field(alias="parentSlug")] = None
    r"""The slug for the parent media item."""

    parent_thumb: Annotated[Optional[str], pydantic.Field(alias="parentThumb")] = None
    r"""The thumbnail URL for the parent media item."""

    parent_title: Annotated[Optional[str], pydantic.Field(alias="parentTitle")] = None
    r"""The title of the parent media item."""

    parent_year: Annotated[Optional[int], pydantic.Field(alias="parentYear")] = None
    r"""The release year of the parent media item."""

    primary_extra_key: Annotated[
        Optional[str], pydantic.Field(alias="primaryExtraKey")
    ] = None
    r"""The primary extra key associated with this media item."""

    rating_image: Annotated[Optional[str], pydantic.Field(alias="ratingImage")] = None
    r"""The URL for the rating image."""

    skip_count: Annotated[Optional[int], pydantic.Field(alias="skipCount")] = None
    r"""The number of times this media item has been skipped."""

    studio: Optional[str] = None
    r"""The studio that produced the media item."""

    subtype: Optional[str] = None
    r"""A classification that further describes the type of media item. For example, 'clip' indicates that the item is a short video clip."""

    updated_at: Annotated[Optional[int], pydantic.Field(alias="updatedAt")] = None
    r"""Unix epoch datetime in seconds"""

    user_rating: Annotated[Optional[float], pydantic.Field(alias="userRating")] = None
    r"""The rating provided by a user for the item. This value is expressed as a decimal number."""

    view_count: Annotated[Optional[int], pydantic.Field(alias="viewCount")] = None
    r"""The number of times this media item has been viewed."""

    view_offset: Annotated[Optional[int], pydantic.Field(alias="viewOffset")] = None
    r"""The current playback offset (in milliseconds)."""

    viewed_leaf_count: Annotated[
        Optional[int], pydantic.Field(alias="viewedLeafCount")
    ] = None
    r"""The number of leaf items that have been viewed."""

    year: Optional[int] = None
    r"""The release year of the media item."""

    image: Annotated[
        Optional[List[GetRecentlyAddedImage]], pydantic.Field(alias="Image")
    ] = None

    ultra_blur_colors: Annotated[
        Optional[UltraBlurColors], pydantic.Field(alias="UltraBlurColors")
    ] = None

    media: Annotated[Optional[List[Media]], pydantic.Field(alias="Media")] = None

    genre: Annotated[Optional[List[Genre]], pydantic.Field(alias="Genre")] = None

    country: Annotated[Optional[List[Country]], pydantic.Field(alias="Country")] = None

    director: Annotated[Optional[List[Director]], pydantic.Field(alias="Director")] = (
        None
    )

    writer: Annotated[Optional[List[Writer]], pydantic.Field(alias="Writer")] = None

    role: Annotated[Optional[List[Role]], pydantic.Field(alias="Role")] = None

    producer: Annotated[Optional[List[Producer]], pydantic.Field(alias="Producer")] = (
        None
    )

    rating1: Annotated[Optional[List[Rating]], pydantic.Field(alias="Rating")] = None

    similar: Annotated[Optional[List[Similar]], pydantic.Field(alias="Similar")] = None

    location: Annotated[Optional[List[Location]], pydantic.Field(alias="Location")] = (
        None
    )

    guids: Annotated[Optional[List[Guids]], pydantic.Field(alias="Guid")] = None

    collection: Annotated[
        Optional[List[Collection]], pydantic.Field(alias="Collection")
    ] = None


class GetRecentlyAddedMediaContainerTypedDict(TypedDict):
    size: int
    r"""Number of media items returned in this response."""
    total_size: int
    r"""Total number of media items in the library."""
    offset: int
    r"""Offset value for pagination."""
    allow_sync: bool
    r"""Indicates whether syncing is allowed."""
    identifier: str
    r"""An plugin identifier for the media container."""
    meta: NotRequired[MetaTypedDict]
    r"""The Meta object is only included in the response if the `includeMeta` parameter is set to `1`.

    """
    metadata: NotRequired[List[GetRecentlyAddedMetadataTypedDict]]
    r"""An array of metadata items."""


class GetRecentlyAddedMediaContainer(BaseModel):
    size: int
    r"""Number of media items returned in this response."""

    total_size: Annotated[int, pydantic.Field(alias="totalSize")]
    r"""Total number of media items in the library."""

    offset: int
    r"""Offset value for pagination."""

    allow_sync: Annotated[bool, pydantic.Field(alias="allowSync")]
    r"""Indicates whether syncing is allowed."""

    identifier: str
    r"""An plugin identifier for the media container."""

    meta: Annotated[Optional[Meta], pydantic.Field(alias="Meta")] = None
    r"""The Meta object is only included in the response if the `includeMeta` parameter is set to `1`.

    """

    metadata: Annotated[
        Optional[List[GetRecentlyAddedMetadata]], pydantic.Field(alias="Metadata")
    ] = None
    r"""An array of metadata items."""


class GetRecentlyAddedResponseBodyTypedDict(TypedDict):
    r"""A successful response with recently added content."""

    media_container: NotRequired[GetRecentlyAddedMediaContainerTypedDict]


class GetRecentlyAddedResponseBody(BaseModel):
    r"""A successful response with recently added content."""

    media_container: Annotated[
        Optional[GetRecentlyAddedMediaContainer], pydantic.Field(alias="MediaContainer")
    ] = None


class GetRecentlyAddedResponseTypedDict(TypedDict):
    content_type: str
    r"""HTTP response content type for this operation"""
    status_code: int
    r"""HTTP response status code for this operation"""
    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""
    object: NotRequired[GetRecentlyAddedResponseBodyTypedDict]
    r"""A successful response with recently added content."""


class GetRecentlyAddedResponse(BaseModel):
    content_type: str
    r"""HTTP response content type for this operation"""

    status_code: int
    r"""HTTP response status code for this operation"""

    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""

    object: Optional[GetRecentlyAddedResponseBody] = None
    r"""A successful response with recently added content."""
