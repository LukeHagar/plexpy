"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from enum import Enum
import httpx
from plex_api_client.models.components import accepts as components_accepts
from plex_api_client.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from plex_api_client.utils import FieldMetadata, HeaderMetadata
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


GET_USERS_SERVERS = [
    "https://plex.tv/api",
]


class GetUsersGlobalsTypedDict(TypedDict):
    accepts: NotRequired[components_accepts.Accepts]
    r"""Indicates the client accepts the indicated media types"""
    client_identifier: NotRequired[str]
    r"""An opaque identifier unique to the client"""
    product: NotRequired[str]
    r"""The name of the client product"""
    version: NotRequired[str]
    r"""The version of the client application"""
    platform: NotRequired[str]
    r"""The platform of the client"""
    platform_version: NotRequired[str]
    r"""The version of the platform"""
    device: NotRequired[str]
    r"""A relatively friendly name for the client device"""
    model: NotRequired[str]
    r"""A potentially less friendly identifier for the device model"""
    device_vendor: NotRequired[str]
    r"""The device vendor"""
    device_name: NotRequired[str]
    r"""A friendly name for the client"""
    marketplace: NotRequired[str]
    r"""The marketplace on which the client application is distributed"""


class GetUsersGlobals(BaseModel):
    accepts: Annotated[
        Optional[components_accepts.Accepts],
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = components_accepts.Accepts.APPLICATION_XML
    r"""Indicates the client accepts the indicated media types"""

    client_identifier: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Client-Identifier"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""An opaque identifier unique to the client"""

    product: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Product"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The name of the client product"""

    version: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The version of the client application"""

    platform: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Platform"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The platform of the client"""

    platform_version: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Platform-Version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The version of the platform"""

    device: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A relatively friendly name for the client device"""

    model: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Model"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A potentially less friendly identifier for the device model"""

    device_vendor: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device-Vendor"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The device vendor"""

    device_name: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device-Name"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A friendly name for the client"""

    marketplace: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Marketplace"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The marketplace on which the client application is distributed"""


class GetUsersRequestTypedDict(TypedDict):
    accepts: NotRequired[components_accepts.Accepts]
    r"""Indicates the client accepts the indicated media types"""
    client_identifier: NotRequired[str]
    r"""An opaque identifier unique to the client"""
    product: NotRequired[str]
    r"""The name of the client product"""
    version: NotRequired[str]
    r"""The version of the client application"""
    platform: NotRequired[str]
    r"""The platform of the client"""
    platform_version: NotRequired[str]
    r"""The version of the platform"""
    device: NotRequired[str]
    r"""A relatively friendly name for the client device"""
    model: NotRequired[str]
    r"""A potentially less friendly identifier for the device model"""
    device_vendor: NotRequired[str]
    r"""The device vendor"""
    device_name: NotRequired[str]
    r"""A friendly name for the client"""
    marketplace: NotRequired[str]
    r"""The marketplace on which the client application is distributed"""


class GetUsersRequest(BaseModel):
    accepts: Annotated[
        Optional[components_accepts.Accepts],
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = components_accepts.Accepts.APPLICATION_XML
    r"""Indicates the client accepts the indicated media types"""

    client_identifier: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Client-Identifier"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""An opaque identifier unique to the client"""

    product: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Product"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The name of the client product"""

    version: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The version of the client application"""

    platform: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Platform"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The platform of the client"""

    platform_version: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Platform-Version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The version of the platform"""

    device: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A relatively friendly name for the client device"""

    model: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Model"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A potentially less friendly identifier for the device model"""

    device_vendor: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device-Vendor"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The device vendor"""

    device_name: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device-Name"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A friendly name for the client"""

    marketplace: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Marketplace"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The marketplace on which the client application is distributed"""


class Protected(int, Enum):
    r"""Indicates whether the account is protected."""

    DISABLE = 0
    ENABLE = 1


class Home(int, Enum):
    r"""Indicates if the user is part of a home group."""

    DISABLE = 0
    ENABLE = 1


class AllowTuners(int, Enum):
    r"""Indicates if the user is allowed to use tuners."""

    DISABLE = 0
    ENABLE = 1


class AllowSync(int, Enum):
    r"""Indicates if the user is allowed to sync media."""

    DISABLE = 0
    ENABLE = 1


class AllowCameraUpload(int, Enum):
    r"""Indicates if the user is allowed to upload from a camera."""

    DISABLE = 0
    ENABLE = 1


class AllowChannels(int, Enum):
    r"""Indicates if the user has access to channels."""

    DISABLE = 0
    ENABLE = 1


class AllowSubtitleAdmin(int, Enum):
    r"""Indicates if the user can manage subtitles."""

    DISABLE = 0
    ENABLE = 1


class Restricted(int, Enum):
    r"""Indicates if the user has restricted access."""

    DISABLE = 0
    ENABLE = 1


class AllLibraries(int, Enum):
    r"""Indicates if the user has access to all libraries."""

    DISABLE = 0
    ENABLE = 1


class Owned(int, Enum):
    r"""Indicates if the user owns the server."""

    DISABLE = 0
    ENABLE = 1


class Pending(int, Enum):
    r"""Indicates if the server is pending approval."""

    DISABLE = 0
    ENABLE = 1


class ServerTypedDict(TypedDict):
    id: int
    r"""Unique ID of the server of the connected user"""
    server_id: int
    r"""ID of the actual Plex server."""
    machine_identifier: str
    r"""Machine identifier of the Plex server."""
    name: str
    r"""Name of the Plex server of the connected user."""
    last_seen_at: int
    r"""Unix epoch datetime in seconds"""
    num_libraries: int
    r"""Number of libraries in the server this user has access to."""
    all_libraries: NotRequired[AllLibraries]
    owned: NotRequired[Owned]
    pending: NotRequired[Pending]


class Server(BaseModel):
    id: int
    r"""Unique ID of the server of the connected user"""

    server_id: Annotated[int, pydantic.Field(alias="serverId")]
    r"""ID of the actual Plex server."""

    machine_identifier: Annotated[str, pydantic.Field(alias="machineIdentifier")]
    r"""Machine identifier of the Plex server."""

    name: str
    r"""Name of the Plex server of the connected user."""

    last_seen_at: Annotated[int, pydantic.Field(alias="lastSeenAt")]
    r"""Unix epoch datetime in seconds"""

    num_libraries: Annotated[int, pydantic.Field(alias="numLibraries")]
    r"""Number of libraries in the server this user has access to."""

    all_libraries: Annotated[
        Optional[AllLibraries], pydantic.Field(alias="allLibraries")
    ] = AllLibraries.DISABLE

    owned: Optional[Owned] = Owned.DISABLE

    pending: Optional[Pending] = Pending.DISABLE


class UserTypedDict(TypedDict):
    id: int
    r"""User's unique ID."""
    title: str
    r"""User's display name."""
    username: str
    r"""User's username."""
    email: str
    r"""User's email address."""
    thumb: str
    r"""URL to the user's avatar image."""
    server: List[ServerTypedDict]
    r"""List of servers owned by the user."""
    recommendations_playlist_id: NotRequired[Nullable[str]]
    r"""ID of the user's recommendation playlist."""
    protected: NotRequired[Protected]
    home: NotRequired[Home]
    allow_tuners: NotRequired[AllowTuners]
    allow_sync: NotRequired[AllowSync]
    allow_camera_upload: NotRequired[AllowCameraUpload]
    allow_channels: NotRequired[AllowChannels]
    allow_subtitle_admin: NotRequired[AllowSubtitleAdmin]
    filter_all: NotRequired[Nullable[str]]
    r"""Filters applied for all content."""
    filter_movies: NotRequired[Nullable[str]]
    r"""Filters applied for movies."""
    filter_music: NotRequired[Nullable[str]]
    r"""Filters applied for music."""
    filter_photos: NotRequired[Nullable[str]]
    r"""Filters applied for photos."""
    filter_television: NotRequired[str]
    r"""Filters applied for television."""
    restricted: NotRequired[Restricted]


class User(BaseModel):
    id: int
    r"""User's unique ID."""

    title: str
    r"""User's display name."""

    username: str
    r"""User's username."""

    email: str
    r"""User's email address."""

    thumb: str
    r"""URL to the user's avatar image."""

    server: Annotated[List[Server], pydantic.Field(alias="Server")]
    r"""List of servers owned by the user."""

    recommendations_playlist_id: Annotated[
        OptionalNullable[str], pydantic.Field(alias="recommendationsPlaylistId")
    ] = UNSET
    r"""ID of the user's recommendation playlist."""

    protected: Optional[Protected] = Protected.DISABLE

    home: Optional[Home] = Home.DISABLE

    allow_tuners: Annotated[
        Optional[AllowTuners], pydantic.Field(alias="allowTuners")
    ] = AllowTuners.DISABLE

    allow_sync: Annotated[Optional[AllowSync], pydantic.Field(alias="allowSync")] = (
        AllowSync.DISABLE
    )

    allow_camera_upload: Annotated[
        Optional[AllowCameraUpload], pydantic.Field(alias="allowCameraUpload")
    ] = AllowCameraUpload.DISABLE

    allow_channels: Annotated[
        Optional[AllowChannels], pydantic.Field(alias="allowChannels")
    ] = AllowChannels.DISABLE

    allow_subtitle_admin: Annotated[
        Optional[AllowSubtitleAdmin], pydantic.Field(alias="allowSubtitleAdmin")
    ] = AllowSubtitleAdmin.DISABLE

    filter_all: Annotated[OptionalNullable[str], pydantic.Field(alias="filterAll")] = (
        UNSET
    )
    r"""Filters applied for all content."""

    filter_movies: Annotated[
        OptionalNullable[str], pydantic.Field(alias="filterMovies")
    ] = UNSET
    r"""Filters applied for movies."""

    filter_music: Annotated[
        OptionalNullable[str], pydantic.Field(alias="filterMusic")
    ] = UNSET
    r"""Filters applied for music."""

    filter_photos: Annotated[
        OptionalNullable[str], pydantic.Field(alias="filterPhotos")
    ] = UNSET
    r"""Filters applied for photos."""

    filter_television: Annotated[
        Optional[str], pydantic.Field(alias="filterTelevision")
    ] = None
    r"""Filters applied for television."""

    restricted: Optional[Restricted] = Restricted.DISABLE

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "recommendationsPlaylistId",
            "protected",
            "home",
            "allowTuners",
            "allowSync",
            "allowCameraUpload",
            "allowChannels",
            "allowSubtitleAdmin",
            "filterAll",
            "filterMovies",
            "filterMusic",
            "filterPhotos",
            "filterTelevision",
            "restricted",
        ]
        nullable_fields = [
            "recommendationsPlaylistId",
            "filterAll",
            "filterMovies",
            "filterMusic",
            "filterPhotos",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetUsersMediaContainerTypedDict(TypedDict):
    r"""Container holding user and server details."""

    friendly_name: str
    r"""The friendly name of the Plex instance."""
    identifier: str
    machine_identifier: str
    r"""Unique Machine identifier of the Plex server."""
    total_size: int
    r"""Total number of users."""
    size: int
    r"""Number of users in the current response."""
    user: List[UserTypedDict]
    r"""List of users with access to the Plex server."""


class GetUsersMediaContainer(BaseModel):
    r"""Container holding user and server details."""

    friendly_name: Annotated[str, pydantic.Field(alias="friendlyName")]
    r"""The friendly name of the Plex instance."""

    identifier: str

    machine_identifier: Annotated[str, pydantic.Field(alias="machineIdentifier")]
    r"""Unique Machine identifier of the Plex server."""

    total_size: Annotated[int, pydantic.Field(alias="totalSize")]
    r"""Total number of users."""

    size: int
    r"""Number of users in the current response."""

    user: Annotated[List[User], pydantic.Field(alias="User")]
    r"""List of users with access to the Plex server."""


class GetUsersResponseBodyTypedDict(TypedDict):
    r"""Successful response with media container data in JSON"""

    media_container: NotRequired[GetUsersMediaContainerTypedDict]
    r"""Container holding user and server details."""


class GetUsersResponseBody(BaseModel):
    r"""Successful response with media container data in JSON"""

    media_container: Annotated[
        Optional[GetUsersMediaContainer], pydantic.Field(alias="MediaContainer")
    ] = None
    r"""Container holding user and server details."""


class GetUsersResponseTypedDict(TypedDict):
    content_type: str
    r"""HTTP response content type for this operation"""
    status_code: int
    r"""HTTP response status code for this operation"""
    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""
    object: NotRequired[GetUsersResponseBodyTypedDict]
    r"""Successful response with media container data in JSON"""


class GetUsersResponse(BaseModel):
    content_type: str
    r"""HTTP response content type for this operation"""

    status_code: int
    r"""HTTP response status code for this operation"""

    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""

    object: Optional[GetUsersResponseBody] = None
    r"""Successful response with media container data in JSON"""
