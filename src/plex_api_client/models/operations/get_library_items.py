"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import date
from enum import Enum
import httpx
from plex_api_client import utils
from plex_api_client.types import BaseModel
from plex_api_client.utils import (
    FieldMetadata,
    PathParamMetadata,
    QueryParamMetadata,
    validate_open_enum,
)
import pydantic
from pydantic.functional_validators import PlainValidator
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class Tag(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""A key representing a specific tag within the section."""

    UNWATCHED = "unwatched"
    NEWEST = "newest"
    RECENTLY_ADDED = "recentlyAdded"
    RECENTLY_VIEWED = "recentlyViewed"
    ON_DECK = "onDeck"
    COLLECTION = "collection"
    EDITION = "edition"
    YEAR = "year"
    DECADE = "decade"
    DIRECTOR = "director"
    CONTENT_RATING = "contentRating"
    RATING = "rating"
    RESOLUTION = "resolution"
    FIRST_CHARACTER = "firstCharacter"
    FOLDER = "folder"
    ALBUMS = "albums"


class IncludeGuids(int, Enum):
    r"""Adds the Guids object to the response"""

    DISABLE = 0
    ENABLE = 1


class GetLibraryItemsQueryParamType(int, Enum, metaclass=utils.OpenEnumMeta):
    r"""The type of media to retrieve or filter by.
    1 = movie
    2 = show
    3 = season
    4 = episode
    E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries

    """

    MOVIE = 1
    TV_SHOW = 2
    SEASON = 3
    EPISODE = 4
    AUDIO = 8
    ALBUM = 9
    TRACK = 10


class GetLibraryItemsQueryParamIncludeMeta(int, Enum):
    r"""Adds the Meta object to the response"""

    DISABLE = 0
    ENABLE = 1


class GetLibraryItemsRequestTypedDict(TypedDict):
    tag: Tag
    r"""A key representing a specific tag within the section."""
    type: GetLibraryItemsQueryParamType
    r"""The type of media to retrieve or filter by.
    1 = movie
    2 = show
    3 = season
    4 = episode
    E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries

    """
    section_key: int
    r"""The unique key of the Plex library.
    Note: This is unique in the context of the Plex server.

    """
    include_guids: NotRequired[IncludeGuids]
    r"""Adds the Guids object to the response

    """
    include_meta: NotRequired[GetLibraryItemsQueryParamIncludeMeta]
    r"""Adds the Meta object to the response

    """
    x_plex_container_start: NotRequired[int]
    r"""The index of the first item to return. If not specified, the first item will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 0

    """
    x_plex_container_size: NotRequired[int]
    r"""The number of items to return. If not specified, all items will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 50

    """


class GetLibraryItemsRequest(BaseModel):
    tag: Annotated[
        Annotated[Tag, PlainValidator(validate_open_enum(False))],
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""A key representing a specific tag within the section."""

    type: Annotated[
        Annotated[
            GetLibraryItemsQueryParamType, PlainValidator(validate_open_enum(True))
        ],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ]
    r"""The type of media to retrieve or filter by.
    1 = movie
    2 = show
    3 = season
    4 = episode
    E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries

    """

    section_key: Annotated[
        int,
        pydantic.Field(alias="sectionKey"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""The unique key of the Plex library.
    Note: This is unique in the context of the Plex server.

    """

    include_guids: Annotated[
        Optional[IncludeGuids],
        pydantic.Field(alias="includeGuids"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = IncludeGuids.DISABLE
    r"""Adds the Guids object to the response

    """

    include_meta: Annotated[
        Optional[GetLibraryItemsQueryParamIncludeMeta],
        pydantic.Field(alias="includeMeta"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = GetLibraryItemsQueryParamIncludeMeta.DISABLE
    r"""Adds the Meta object to the response

    """

    x_plex_container_start: Annotated[
        Optional[int],
        pydantic.Field(alias="X-Plex-Container-Start"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 0
    r"""The index of the first item to return. If not specified, the first item will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 0

    """

    x_plex_container_size: Annotated[
        Optional[int],
        pydantic.Field(alias="X-Plex-Container-Size"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 50
    r"""The number of items to return. If not specified, all items will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 50

    """


class GetLibraryItemsFilterTypedDict(TypedDict):
    filter_: str
    filter_type: str
    key: str
    title: str
    type: str
    advanced: NotRequired[bool]


class GetLibraryItemsFilter(BaseModel):
    filter_: Annotated[str, pydantic.Field(alias="filter")]

    filter_type: Annotated[str, pydantic.Field(alias="filterType")]

    key: str

    title: str

    type: str

    advanced: Optional[bool] = None


class GetLibraryItemsActiveDirection(str, Enum):
    r"""The direction of the sort. Can be either `asc` or `desc`."""

    ASCENDING = "asc"
    DESCENDING = "desc"


class GetLibraryItemsDefaultDirection(str, Enum):
    r"""The direction of the sort. Can be either `asc` or `desc`."""

    ASCENDING = "asc"
    DESCENDING = "desc"


class GetLibraryItemsSortTypedDict(TypedDict):
    key: str
    title: str
    default: NotRequired[str]
    active: NotRequired[bool]
    active_direction: NotRequired[GetLibraryItemsActiveDirection]
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """
    default_direction: NotRequired[GetLibraryItemsDefaultDirection]
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """
    desc_key: NotRequired[str]
    first_character_key: NotRequired[str]


class GetLibraryItemsSort(BaseModel):
    key: str

    title: str

    default: Optional[str] = None

    active: Optional[bool] = None

    active_direction: Annotated[
        Optional[GetLibraryItemsActiveDirection],
        pydantic.Field(alias="activeDirection"),
    ] = GetLibraryItemsActiveDirection.ASCENDING
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """

    default_direction: Annotated[
        Optional[GetLibraryItemsDefaultDirection],
        pydantic.Field(alias="defaultDirection"),
    ] = GetLibraryItemsDefaultDirection.ASCENDING
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """

    desc_key: Annotated[Optional[str], pydantic.Field(alias="descKey")] = None

    first_character_key: Annotated[
        Optional[str], pydantic.Field(alias="firstCharacterKey")
    ] = None


class GetLibraryItemsFieldTypedDict(TypedDict):
    key: str
    title: str
    type: str
    sub_type: NotRequired[str]


class GetLibraryItemsField(BaseModel):
    key: str

    title: str

    type: str

    sub_type: Annotated[Optional[str], pydantic.Field(alias="subType")] = None


class GetLibraryItemsTypeTypedDict(TypedDict):
    key: str
    type: str
    title: str
    active: bool
    subtype: NotRequired[str]
    filter_: NotRequired[List[GetLibraryItemsFilterTypedDict]]
    sort: NotRequired[List[GetLibraryItemsSortTypedDict]]
    field: NotRequired[List[GetLibraryItemsFieldTypedDict]]


class GetLibraryItemsType(BaseModel):
    key: str

    type: str

    title: str

    active: bool

    subtype: Optional[str] = None

    filter_: Annotated[
        Optional[List[GetLibraryItemsFilter]], pydantic.Field(alias="Filter")
    ] = None

    sort: Annotated[
        Optional[List[GetLibraryItemsSort]], pydantic.Field(alias="Sort")
    ] = None

    field: Annotated[
        Optional[List[GetLibraryItemsField]], pydantic.Field(alias="Field")
    ] = None


class GetLibraryItemsOperatorTypedDict(TypedDict):
    key: str
    title: str


class GetLibraryItemsOperator(BaseModel):
    key: str

    title: str


class GetLibraryItemsFieldTypeTypedDict(TypedDict):
    type: str
    operator: List[GetLibraryItemsOperatorTypedDict]


class GetLibraryItemsFieldType(BaseModel):
    type: str

    operator: Annotated[List[GetLibraryItemsOperator], pydantic.Field(alias="Operator")]


class GetLibraryItemsLibraryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The type of media content"""

    MOVIE = "movie"
    TV_SHOW = "show"
    SEASON = "season"
    EPISODE = "episode"
    ARTIST = "artist"
    ALBUM = "album"


class FlattenSeasons(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Setting that indicates if seasons are set to hidden for the show. (-1 = Library default, 0 = Hide, 1 = Show)."""

    LIBRARY_DEFAULT = "-1"
    HIDE = "0"
    SHOW = "1"


class EpisodeSort(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Setting that indicates how episodes are sorted for the show. (-1 = Library default, 0 = Oldest first, 1 = Newest first)."""

    LIBRARY_DEFAULT = "-1"
    OLDEST_FIRST = "0"
    NEWEST_FIRST = "1"


class EnableCreditsMarkerGeneration(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Setting that indicates if credits markers detection is enabled. (-1 = Library default, 0 = Disabled)."""

    LIBRARY_DEFAULT = "-1"
    DISABLED = "0"


class ShowOrdering(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Setting that indicates the episode ordering for the show.
    None = Library default,
    tmdbAiring = The Movie Database (Aired),
    aired = TheTVDB (Aired),
    dvd = TheTVDB (DVD),
    absolute = TheTVDB (Absolute)).

    """

    NONE = "None"
    TMDB_AIRING = "tmdbAiring"
    TVDB_AIRED = "aired"
    TVDB_DVD = "dvd"
    TVDB_ABSOLUTE = "absolute"


class GetLibraryItemsOptimizedForStreaming(int, Enum):
    DISABLE = 0
    ENABLE = 1


class GetLibraryItemsHasThumbnail(str, Enum):
    FALSE = "0"
    TRUE = "1"


class GetLibraryItemsStreamTypedDict(TypedDict):
    id: int
    stream_type: int
    r"""Type of stream (1 = video, 2 = audio, 3 = subtitle)"""
    codec: str
    r"""Codec used by the stream"""
    index: int
    r"""The index of the stream"""
    default: NotRequired[bool]
    r"""Indicates if this is the default stream"""
    selected: NotRequired[bool]
    r"""Indicates if the stream is selected"""
    bitrate: NotRequired[int]
    r"""The bitrate of the stream in kbps"""
    color_primaries: NotRequired[str]
    r"""The color primaries of the video stream"""
    color_range: NotRequired[str]
    r"""The color range of the video stream"""
    color_space: NotRequired[str]
    r"""The color space of the video stream"""
    color_trc: NotRequired[str]
    r"""The transfer characteristics (TRC) of the video stream"""
    bit_depth: NotRequired[int]
    r"""The bit depth of the video stream"""
    chroma_location: NotRequired[str]
    r"""The chroma location of the video stream"""
    stream_identifier: NotRequired[str]
    r"""The identifier of the video stream"""
    chroma_subsampling: NotRequired[str]
    r"""The chroma subsampling format"""
    coded_height: NotRequired[int]
    r"""The coded height of the video stream"""
    coded_width: NotRequired[int]
    r"""The coded width of the video stream"""
    frame_rate: NotRequired[float]
    r"""The frame rate of the video stream"""
    has_scaling_matrix: NotRequired[bool]
    r"""Indicates if the stream has a scaling matrix"""
    hearing_impaired: NotRequired[bool]
    closed_captions: NotRequired[bool]
    embedded_in_video: NotRequired[str]
    height: NotRequired[int]
    r"""The height of the video stream"""
    level: NotRequired[int]
    r"""The level of the video codec"""
    profile: NotRequired[str]
    r"""The profile of the video codec"""
    ref_frames: NotRequired[int]
    r"""Number of reference frames"""
    scan_type: NotRequired[str]
    r"""The scan type (progressive or interlaced)"""
    width: NotRequired[int]
    r"""The width of the video stream"""
    display_title: NotRequired[str]
    r"""Display title of the stream"""
    extended_display_title: NotRequired[str]
    r"""Extended display title of the stream"""
    channels: NotRequired[int]
    r"""Number of audio channels (for audio streams)"""
    language: NotRequired[str]
    r"""The language of the stream (for audio/subtitle streams)"""
    language_tag: NotRequired[str]
    r"""Language tag of the stream"""
    language_code: NotRequired[str]
    r"""Language code of the stream"""
    audio_channel_layout: NotRequired[str]
    r"""The audio channel layout"""
    sampling_rate: NotRequired[int]
    r"""Sampling rate of the audio stream in Hz"""
    title: NotRequired[str]
    r"""Title of the subtitle track (for subtitle streams)"""
    can_auto_sync: NotRequired[bool]
    r"""Indicates if the subtitle stream can auto-sync"""


class GetLibraryItemsStream(BaseModel):
    id: int

    stream_type: Annotated[int, pydantic.Field(alias="streamType")]
    r"""Type of stream (1 = video, 2 = audio, 3 = subtitle)"""

    codec: str
    r"""Codec used by the stream"""

    index: int
    r"""The index of the stream"""

    default: Optional[bool] = None
    r"""Indicates if this is the default stream"""

    selected: Optional[bool] = None
    r"""Indicates if the stream is selected"""

    bitrate: Optional[int] = None
    r"""The bitrate of the stream in kbps"""

    color_primaries: Annotated[
        Optional[str], pydantic.Field(alias="colorPrimaries")
    ] = None
    r"""The color primaries of the video stream"""

    color_range: Annotated[Optional[str], pydantic.Field(alias="colorRange")] = None
    r"""The color range of the video stream"""

    color_space: Annotated[Optional[str], pydantic.Field(alias="colorSpace")] = None
    r"""The color space of the video stream"""

    color_trc: Annotated[Optional[str], pydantic.Field(alias="colorTrc")] = None
    r"""The transfer characteristics (TRC) of the video stream"""

    bit_depth: Annotated[Optional[int], pydantic.Field(alias="bitDepth")] = None
    r"""The bit depth of the video stream"""

    chroma_location: Annotated[
        Optional[str], pydantic.Field(alias="chromaLocation")
    ] = None
    r"""The chroma location of the video stream"""

    stream_identifier: Annotated[
        Optional[str], pydantic.Field(alias="streamIdentifier")
    ] = None
    r"""The identifier of the video stream"""

    chroma_subsampling: Annotated[
        Optional[str], pydantic.Field(alias="chromaSubsampling")
    ] = None
    r"""The chroma subsampling format"""

    coded_height: Annotated[Optional[int], pydantic.Field(alias="codedHeight")] = None
    r"""The coded height of the video stream"""

    coded_width: Annotated[Optional[int], pydantic.Field(alias="codedWidth")] = None
    r"""The coded width of the video stream"""

    frame_rate: Annotated[Optional[float], pydantic.Field(alias="frameRate")] = None
    r"""The frame rate of the video stream"""

    has_scaling_matrix: Annotated[
        Optional[bool], pydantic.Field(alias="hasScalingMatrix")
    ] = None
    r"""Indicates if the stream has a scaling matrix"""

    hearing_impaired: Annotated[
        Optional[bool], pydantic.Field(alias="hearingImpaired")
    ] = None

    closed_captions: Annotated[
        Optional[bool], pydantic.Field(alias="closedCaptions")
    ] = None

    embedded_in_video: Annotated[
        Optional[str], pydantic.Field(alias="embeddedInVideo")
    ] = None

    height: Optional[int] = None
    r"""The height of the video stream"""

    level: Optional[int] = None
    r"""The level of the video codec"""

    profile: Optional[str] = None
    r"""The profile of the video codec"""

    ref_frames: Annotated[Optional[int], pydantic.Field(alias="refFrames")] = None
    r"""Number of reference frames"""

    scan_type: Annotated[Optional[str], pydantic.Field(alias="scanType")] = None
    r"""The scan type (progressive or interlaced)"""

    width: Optional[int] = None
    r"""The width of the video stream"""

    display_title: Annotated[Optional[str], pydantic.Field(alias="displayTitle")] = None
    r"""Display title of the stream"""

    extended_display_title: Annotated[
        Optional[str], pydantic.Field(alias="extendedDisplayTitle")
    ] = None
    r"""Extended display title of the stream"""

    channels: Optional[int] = None
    r"""Number of audio channels (for audio streams)"""

    language: Optional[str] = None
    r"""The language of the stream (for audio/subtitle streams)"""

    language_tag: Annotated[Optional[str], pydantic.Field(alias="languageTag")] = None
    r"""Language tag of the stream"""

    language_code: Annotated[Optional[str], pydantic.Field(alias="languageCode")] = None
    r"""Language code of the stream"""

    audio_channel_layout: Annotated[
        Optional[str], pydantic.Field(alias="audioChannelLayout")
    ] = None
    r"""The audio channel layout"""

    sampling_rate: Annotated[Optional[int], pydantic.Field(alias="samplingRate")] = None
    r"""Sampling rate of the audio stream in Hz"""

    title: Optional[str] = None
    r"""Title of the subtitle track (for subtitle streams)"""

    can_auto_sync: Annotated[Optional[bool], pydantic.Field(alias="canAutoSync")] = None
    r"""Indicates if the subtitle stream can auto-sync"""


class GetLibraryItemsPartTypedDict(TypedDict):
    id: int
    key: str
    file: str
    size: int
    container: str
    r"""The container format of the media file.

    """
    duration: NotRequired[int]
    audio_profile: NotRequired[str]
    has64bit_offsets: NotRequired[bool]
    optimized_for_streaming: NotRequired[bool]
    video_profile: NotRequired[str]
    indexes: NotRequired[str]
    has_thumbnail: NotRequired[GetLibraryItemsHasThumbnail]
    stream: NotRequired[List[GetLibraryItemsStreamTypedDict]]


class GetLibraryItemsPart(BaseModel):
    id: int

    key: str

    file: str

    size: int

    container: str
    r"""The container format of the media file.

    """

    duration: Optional[int] = None

    audio_profile: Annotated[Optional[str], pydantic.Field(alias="audioProfile")] = None

    has64bit_offsets: Annotated[
        Optional[bool], pydantic.Field(alias="has64bitOffsets")
    ] = None

    optimized_for_streaming: Annotated[
        Optional[bool], pydantic.Field(alias="optimizedForStreaming")
    ] = None

    video_profile: Annotated[Optional[str], pydantic.Field(alias="videoProfile")] = None

    indexes: Optional[str] = None

    has_thumbnail: Annotated[
        Optional[GetLibraryItemsHasThumbnail], pydantic.Field(alias="hasThumbnail")
    ] = GetLibraryItemsHasThumbnail.FALSE

    stream: Annotated[
        Optional[List[GetLibraryItemsStream]], pydantic.Field(alias="Stream")
    ] = None


class GetLibraryItemsMediaTypedDict(TypedDict):
    id: int
    container: str
    part: List[GetLibraryItemsPartTypedDict]
    duration: NotRequired[int]
    bitrate: NotRequired[int]
    width: NotRequired[int]
    height: NotRequired[int]
    aspect_ratio: NotRequired[float]
    audio_profile: NotRequired[str]
    audio_channels: NotRequired[int]
    audio_codec: NotRequired[str]
    video_codec: NotRequired[str]
    video_resolution: NotRequired[str]
    video_frame_rate: NotRequired[str]
    video_profile: NotRequired[str]
    has_voice_activity: NotRequired[bool]
    optimized_for_streaming: NotRequired[GetLibraryItemsOptimizedForStreaming]
    has64bit_offsets: NotRequired[bool]


class GetLibraryItemsMedia(BaseModel):
    id: int

    container: str

    part: Annotated[List[GetLibraryItemsPart], pydantic.Field(alias="Part")]

    duration: Optional[int] = None

    bitrate: Optional[int] = None

    width: Optional[int] = None

    height: Optional[int] = None

    aspect_ratio: Annotated[Optional[float], pydantic.Field(alias="aspectRatio")] = None

    audio_profile: Annotated[Optional[str], pydantic.Field(alias="audioProfile")] = None

    audio_channels: Annotated[Optional[int], pydantic.Field(alias="audioChannels")] = (
        None
    )

    audio_codec: Annotated[Optional[str], pydantic.Field(alias="audioCodec")] = None

    video_codec: Annotated[Optional[str], pydantic.Field(alias="videoCodec")] = None

    video_resolution: Annotated[
        Optional[str], pydantic.Field(alias="videoResolution")
    ] = None

    video_frame_rate: Annotated[
        Optional[str], pydantic.Field(alias="videoFrameRate")
    ] = None

    video_profile: Annotated[Optional[str], pydantic.Field(alias="videoProfile")] = None

    has_voice_activity: Annotated[
        Optional[bool], pydantic.Field(alias="hasVoiceActivity")
    ] = None

    optimized_for_streaming: Annotated[
        Optional[GetLibraryItemsOptimizedForStreaming],
        pydantic.Field(alias="optimizedForStreaming"),
    ] = GetLibraryItemsOptimizedForStreaming.DISABLE

    has64bit_offsets: Annotated[
        Optional[bool], pydantic.Field(alias="has64bitOffsets")
    ] = None


class GetLibraryItemsGenreTypedDict(TypedDict):
    tag: NotRequired[str]


class GetLibraryItemsGenre(BaseModel):
    tag: Optional[str] = None


class GetLibraryItemsCountryTypedDict(TypedDict):
    tag: NotRequired[str]


class GetLibraryItemsCountry(BaseModel):
    tag: Optional[str] = None


class GetLibraryItemsDirectorTypedDict(TypedDict):
    tag: NotRequired[str]


class GetLibraryItemsDirector(BaseModel):
    tag: Optional[str] = None


class GetLibraryItemsWriterTypedDict(TypedDict):
    tag: NotRequired[str]


class GetLibraryItemsWriter(BaseModel):
    tag: Optional[str] = None


class GetLibraryItemsCollectionTypedDict(TypedDict):
    tag: NotRequired[str]


class GetLibraryItemsCollection(BaseModel):
    tag: Optional[str] = None


class GetLibraryItemsRoleTypedDict(TypedDict):
    id: NotRequired[int]
    r"""The ID of the tag or actor."""
    filter_: NotRequired[str]
    r"""The filter used to find the actor or tag."""
    thumb: NotRequired[str]
    r"""The thumbnail of the actor"""
    tag: NotRequired[str]
    r"""The name of the tag or actor."""
    tag_key: NotRequired[str]
    r"""Unique identifier for the tag."""
    role: NotRequired[str]
    r"""The role of the actor or tag in the media."""


class GetLibraryItemsRole(BaseModel):
    id: Optional[int] = None
    r"""The ID of the tag or actor."""

    filter_: Annotated[Optional[str], pydantic.Field(alias="filter")] = None
    r"""The filter used to find the actor or tag."""

    thumb: Optional[str] = None
    r"""The thumbnail of the actor"""

    tag: Optional[str] = None
    r"""The name of the tag or actor."""

    tag_key: Annotated[Optional[str], pydantic.Field(alias="tagKey")] = None
    r"""Unique identifier for the tag."""

    role: Optional[str] = None
    r"""The role of the actor or tag in the media."""


class GetLibraryItemsLocationTypedDict(TypedDict):
    path: NotRequired[str]


class GetLibraryItemsLocation(BaseModel):
    path: Optional[str] = None


class MediaGUIDTypedDict(TypedDict):
    id: str
    r"""Can be one of the following formats:
    imdb://tt13015952, tmdb://2434012, tvdb://7945991

    """


class MediaGUID(BaseModel):
    id: str
    r"""Can be one of the following formats:
    imdb://tt13015952, tmdb://2434012, tvdb://7945991

    """


class GetLibraryItemsUltraBlurColorsTypedDict(TypedDict):
    top_left: str
    top_right: str
    bottom_right: str
    bottom_left: str


class GetLibraryItemsUltraBlurColors(BaseModel):
    top_left: Annotated[str, pydantic.Field(alias="topLeft")]

    top_right: Annotated[str, pydantic.Field(alias="topRight")]

    bottom_right: Annotated[str, pydantic.Field(alias="bottomRight")]

    bottom_left: Annotated[str, pydantic.Field(alias="bottomLeft")]


class MetaDataRatingTypedDict(TypedDict):
    image: str
    r"""A URI or path to the rating image."""
    value: float
    r"""The value of the rating."""
    type: str
    r"""The type of rating (e.g., audience, critic)."""


class MetaDataRating(BaseModel):
    image: str
    r"""A URI or path to the rating image."""

    value: float
    r"""The value of the rating."""

    type: str
    r"""The type of rating (e.g., audience, critic)."""


class GetLibraryItemsLibraryResponse200Type(str, Enum, metaclass=utils.OpenEnumMeta):
    COVER_POSTER = "coverPoster"
    BACKGROUND = "background"
    SNAPSHOT = "snapshot"
    CLEAR_LOGO = "clearLogo"


class GetLibraryItemsImageTypedDict(TypedDict):
    alt: str
    type: GetLibraryItemsLibraryResponse200Type
    url: str


class GetLibraryItemsImage(BaseModel):
    alt: str

    type: Annotated[
        GetLibraryItemsLibraryResponse200Type, PlainValidator(validate_open_enum(False))
    ]

    url: str


class GetLibraryItemsMetadataTypedDict(TypedDict):
    rating_key: str
    r"""The rating key (Media ID) of this media item.
    Note: This is always an integer, but is represented as a string in the API.

    """
    key: str
    guid: str
    type: GetLibraryItemsLibraryType
    r"""The type of media content

    """
    title: str
    summary: str
    added_at: int
    r"""Unix epoch datetime in seconds"""
    studio: NotRequired[str]
    skip_children: NotRequired[bool]
    library_section_id: NotRequired[int]
    library_section_title: NotRequired[str]
    library_section_key: NotRequired[str]
    slug: NotRequired[str]
    content_rating: NotRequired[str]
    rating: NotRequired[float]
    audience_rating: NotRequired[float]
    year: NotRequired[int]
    season_count: NotRequired[int]
    tagline: NotRequired[str]
    flatten_seasons: NotRequired[FlattenSeasons]
    r"""Setting that indicates if seasons are set to hidden for the show. (-1 = Library default, 0 = Hide, 1 = Show)."""
    episode_sort: NotRequired[EpisodeSort]
    r"""Setting that indicates how episodes are sorted for the show. (-1 = Library default, 0 = Oldest first, 1 = Newest first)."""
    enable_credits_marker_generation: NotRequired[EnableCreditsMarkerGeneration]
    r"""Setting that indicates if credits markers detection is enabled. (-1 = Library default, 0 = Disabled)."""
    show_ordering: NotRequired[ShowOrdering]
    r"""Setting that indicates the episode ordering for the show.
    None = Library default,
    tmdbAiring = The Movie Database (Aired),
    aired = TheTVDB (Aired),
    dvd = TheTVDB (DVD),
    absolute = TheTVDB (Absolute)).

    """
    thumb: NotRequired[str]
    art: NotRequired[str]
    banner: NotRequired[str]
    duration: NotRequired[int]
    originally_available_at: NotRequired[date]
    updated_at: NotRequired[int]
    r"""Unix epoch datetime in seconds"""
    audience_rating_image: NotRequired[str]
    chapter_source: NotRequired[str]
    primary_extra_key: NotRequired[str]
    rating_image: NotRequired[str]
    grandparent_rating_key: NotRequired[str]
    grandparent_guid: NotRequired[str]
    grandparent_key: NotRequired[str]
    grandparent_title: NotRequired[str]
    grandparent_thumb: NotRequired[str]
    parent_slug: NotRequired[str]
    grandparent_slug: NotRequired[str]
    grandparent_art: NotRequired[str]
    grandparent_theme: NotRequired[str]
    media: NotRequired[List[GetLibraryItemsMediaTypedDict]]
    r"""The Media object is only included when type query is `4` or higher.

    """
    genre: NotRequired[List[GetLibraryItemsGenreTypedDict]]
    country: NotRequired[List[GetLibraryItemsCountryTypedDict]]
    director: NotRequired[List[GetLibraryItemsDirectorTypedDict]]
    writer: NotRequired[List[GetLibraryItemsWriterTypedDict]]
    collection: NotRequired[List[GetLibraryItemsCollectionTypedDict]]
    role: NotRequired[List[GetLibraryItemsRoleTypedDict]]
    location: NotRequired[List[GetLibraryItemsLocationTypedDict]]
    media_guid: NotRequired[List[MediaGUIDTypedDict]]
    r"""The Guid object is only included in the response if the `includeGuids` parameter is set to `1`.

    """
    ultra_blur_colors: NotRequired[GetLibraryItemsUltraBlurColorsTypedDict]
    meta_data_rating: NotRequired[List[MetaDataRatingTypedDict]]
    image: NotRequired[List[GetLibraryItemsImageTypedDict]]
    title_sort: NotRequired[str]
    view_count: NotRequired[int]
    last_viewed_at: NotRequired[int]
    original_title: NotRequired[str]
    view_offset: NotRequired[int]
    skip_count: NotRequired[int]
    index: NotRequired[int]
    theme: NotRequired[str]
    leaf_count: NotRequired[int]
    viewed_leaf_count: NotRequired[int]
    child_count: NotRequired[int]
    has_premium_extras: NotRequired[str]
    has_premium_primary_extra: NotRequired[str]
    parent_rating_key: NotRequired[str]
    r"""The rating key of the parent item.

    """
    parent_guid: NotRequired[str]
    parent_studio: NotRequired[str]
    parent_key: NotRequired[str]
    parent_title: NotRequired[str]
    parent_index: NotRequired[int]
    parent_year: NotRequired[int]
    parent_thumb: NotRequired[str]
    parent_theme: NotRequired[str]


class GetLibraryItemsMetadata(BaseModel):
    rating_key: Annotated[str, pydantic.Field(alias="ratingKey")]
    r"""The rating key (Media ID) of this media item.
    Note: This is always an integer, but is represented as a string in the API.

    """

    key: str

    guid: str

    type: Annotated[
        GetLibraryItemsLibraryType, PlainValidator(validate_open_enum(False))
    ]
    r"""The type of media content

    """

    title: str

    summary: str

    added_at: Annotated[int, pydantic.Field(alias="addedAt")]
    r"""Unix epoch datetime in seconds"""

    studio: Optional[str] = None

    skip_children: Annotated[Optional[bool], pydantic.Field(alias="skipChildren")] = (
        None
    )

    library_section_id: Annotated[
        Optional[int], pydantic.Field(alias="librarySectionID")
    ] = None

    library_section_title: Annotated[
        Optional[str], pydantic.Field(alias="librarySectionTitle")
    ] = None

    library_section_key: Annotated[
        Optional[str], pydantic.Field(alias="librarySectionKey")
    ] = None

    slug: Optional[str] = None

    content_rating: Annotated[Optional[str], pydantic.Field(alias="contentRating")] = (
        None
    )

    rating: Optional[float] = None

    audience_rating: Annotated[
        Optional[float], pydantic.Field(alias="audienceRating")
    ] = None

    year: Optional[int] = None

    season_count: Annotated[Optional[int], pydantic.Field(alias="seasonCount")] = None

    tagline: Optional[str] = None

    flatten_seasons: Annotated[
        Annotated[Optional[FlattenSeasons], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="flattenSeasons"),
    ] = None
    r"""Setting that indicates if seasons are set to hidden for the show. (-1 = Library default, 0 = Hide, 1 = Show)."""

    episode_sort: Annotated[
        Annotated[Optional[EpisodeSort], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="episodeSort"),
    ] = None
    r"""Setting that indicates how episodes are sorted for the show. (-1 = Library default, 0 = Oldest first, 1 = Newest first)."""

    enable_credits_marker_generation: Annotated[
        Annotated[
            Optional[EnableCreditsMarkerGeneration],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="enableCreditsMarkerGeneration"),
    ] = None
    r"""Setting that indicates if credits markers detection is enabled. (-1 = Library default, 0 = Disabled)."""

    show_ordering: Annotated[
        Annotated[Optional[ShowOrdering], PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="showOrdering"),
    ] = None
    r"""Setting that indicates the episode ordering for the show.
    None = Library default,
    tmdbAiring = The Movie Database (Aired),
    aired = TheTVDB (Aired),
    dvd = TheTVDB (DVD),
    absolute = TheTVDB (Absolute)).

    """

    thumb: Optional[str] = None

    art: Optional[str] = None

    banner: Optional[str] = None

    duration: Optional[int] = None

    originally_available_at: Annotated[
        Optional[date], pydantic.Field(alias="originallyAvailableAt")
    ] = None

    updated_at: Annotated[Optional[int], pydantic.Field(alias="updatedAt")] = None
    r"""Unix epoch datetime in seconds"""

    audience_rating_image: Annotated[
        Optional[str], pydantic.Field(alias="audienceRatingImage")
    ] = None

    chapter_source: Annotated[Optional[str], pydantic.Field(alias="chapterSource")] = (
        None
    )

    primary_extra_key: Annotated[
        Optional[str], pydantic.Field(alias="primaryExtraKey")
    ] = None

    rating_image: Annotated[Optional[str], pydantic.Field(alias="ratingImage")] = None

    grandparent_rating_key: Annotated[
        Optional[str], pydantic.Field(alias="grandparentRatingKey")
    ] = None

    grandparent_guid: Annotated[
        Optional[str], pydantic.Field(alias="grandparentGuid")
    ] = None

    grandparent_key: Annotated[
        Optional[str], pydantic.Field(alias="grandparentKey")
    ] = None

    grandparent_title: Annotated[
        Optional[str], pydantic.Field(alias="grandparentTitle")
    ] = None

    grandparent_thumb: Annotated[
        Optional[str], pydantic.Field(alias="grandparentThumb")
    ] = None

    parent_slug: Annotated[Optional[str], pydantic.Field(alias="parentSlug")] = None

    grandparent_slug: Annotated[
        Optional[str], pydantic.Field(alias="grandparentSlug")
    ] = None

    grandparent_art: Annotated[
        Optional[str], pydantic.Field(alias="grandparentArt")
    ] = None

    grandparent_theme: Annotated[
        Optional[str], pydantic.Field(alias="grandparentTheme")
    ] = None

    media: Annotated[
        Optional[List[GetLibraryItemsMedia]], pydantic.Field(alias="Media")
    ] = None
    r"""The Media object is only included when type query is `4` or higher.

    """

    genre: Annotated[
        Optional[List[GetLibraryItemsGenre]], pydantic.Field(alias="Genre")
    ] = None

    country: Annotated[
        Optional[List[GetLibraryItemsCountry]], pydantic.Field(alias="Country")
    ] = None

    director: Annotated[
        Optional[List[GetLibraryItemsDirector]], pydantic.Field(alias="Director")
    ] = None

    writer: Annotated[
        Optional[List[GetLibraryItemsWriter]], pydantic.Field(alias="Writer")
    ] = None

    collection: Annotated[
        Optional[List[GetLibraryItemsCollection]], pydantic.Field(alias="Collection")
    ] = None

    role: Annotated[
        Optional[List[GetLibraryItemsRole]], pydantic.Field(alias="Role")
    ] = None

    location: Annotated[
        Optional[List[GetLibraryItemsLocation]], pydantic.Field(alias="Location")
    ] = None

    media_guid: Annotated[Optional[List[MediaGUID]], pydantic.Field(alias="Guid")] = (
        None
    )
    r"""The Guid object is only included in the response if the `includeGuids` parameter is set to `1`.

    """

    ultra_blur_colors: Annotated[
        Optional[GetLibraryItemsUltraBlurColors],
        pydantic.Field(alias="UltraBlurColors"),
    ] = None

    meta_data_rating: Annotated[
        Optional[List[MetaDataRating]], pydantic.Field(alias="Rating")
    ] = None

    image: Annotated[
        Optional[List[GetLibraryItemsImage]], pydantic.Field(alias="Image")
    ] = None

    title_sort: Annotated[Optional[str], pydantic.Field(alias="titleSort")] = None

    view_count: Annotated[Optional[int], pydantic.Field(alias="viewCount")] = None

    last_viewed_at: Annotated[Optional[int], pydantic.Field(alias="lastViewedAt")] = (
        None
    )

    original_title: Annotated[Optional[str], pydantic.Field(alias="originalTitle")] = (
        None
    )

    view_offset: Annotated[Optional[int], pydantic.Field(alias="viewOffset")] = None

    skip_count: Annotated[Optional[int], pydantic.Field(alias="skipCount")] = None

    index: Optional[int] = None

    theme: Optional[str] = None

    leaf_count: Annotated[Optional[int], pydantic.Field(alias="leafCount")] = None

    viewed_leaf_count: Annotated[
        Optional[int], pydantic.Field(alias="viewedLeafCount")
    ] = None

    child_count: Annotated[Optional[int], pydantic.Field(alias="childCount")] = None

    has_premium_extras: Annotated[
        Optional[str], pydantic.Field(alias="hasPremiumExtras")
    ] = None

    has_premium_primary_extra: Annotated[
        Optional[str], pydantic.Field(alias="hasPremiumPrimaryExtra")
    ] = None

    parent_rating_key: Annotated[
        Optional[str], pydantic.Field(alias="parentRatingKey")
    ] = None
    r"""The rating key of the parent item.

    """

    parent_guid: Annotated[Optional[str], pydantic.Field(alias="parentGuid")] = None

    parent_studio: Annotated[Optional[str], pydantic.Field(alias="parentStudio")] = None

    parent_key: Annotated[Optional[str], pydantic.Field(alias="parentKey")] = None

    parent_title: Annotated[Optional[str], pydantic.Field(alias="parentTitle")] = None

    parent_index: Annotated[Optional[int], pydantic.Field(alias="parentIndex")] = None

    parent_year: Annotated[Optional[int], pydantic.Field(alias="parentYear")] = None

    parent_thumb: Annotated[Optional[str], pydantic.Field(alias="parentThumb")] = None

    parent_theme: Annotated[Optional[str], pydantic.Field(alias="parentTheme")] = None


class GetLibraryItemsLibraryFilterTypedDict(TypedDict):
    filter_: str
    filter_type: str
    key: str
    title: str
    type: str


class GetLibraryItemsLibraryFilter(BaseModel):
    filter_: Annotated[str, pydantic.Field(alias="filter")]

    filter_type: Annotated[str, pydantic.Field(alias="filterType")]

    key: str

    title: str

    type: str


class GetLibraryItemsLibraryActiveDirection(str, Enum):
    r"""The direction of the sort. Can be either `asc` or `desc`."""

    ASCENDING = "asc"
    DESCENDING = "desc"


class GetLibraryItemsLibraryDefaultDirection(str, Enum):
    r"""The direction of the sort. Can be either `asc` or `desc`."""

    ASCENDING = "asc"
    DESCENDING = "desc"


class GetLibraryItemsLibrarySortTypedDict(TypedDict):
    key: str
    title: str
    default: NotRequired[str]
    active: NotRequired[bool]
    active_direction: NotRequired[GetLibraryItemsLibraryActiveDirection]
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """
    default_direction: NotRequired[GetLibraryItemsLibraryDefaultDirection]
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """
    desc_key: NotRequired[str]
    first_character_key: NotRequired[str]


class GetLibraryItemsLibrarySort(BaseModel):
    key: str

    title: str

    default: Optional[str] = None

    active: Optional[bool] = None

    active_direction: Annotated[
        Optional[GetLibraryItemsLibraryActiveDirection],
        pydantic.Field(alias="activeDirection"),
    ] = GetLibraryItemsLibraryActiveDirection.ASCENDING
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """

    default_direction: Annotated[
        Optional[GetLibraryItemsLibraryDefaultDirection],
        pydantic.Field(alias="defaultDirection"),
    ] = GetLibraryItemsLibraryDefaultDirection.ASCENDING
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """

    desc_key: Annotated[Optional[str], pydantic.Field(alias="descKey")] = None

    first_character_key: Annotated[
        Optional[str], pydantic.Field(alias="firstCharacterKey")
    ] = None


class GetLibraryItemsLibraryFieldTypedDict(TypedDict):
    key: str
    title: str
    type: str
    sub_type: NotRequired[str]


class GetLibraryItemsLibraryField(BaseModel):
    key: str

    title: str

    type: str

    sub_type: Annotated[Optional[str], pydantic.Field(alias="subType")] = None


class GetLibraryItemsLibraryResponseTypeTypedDict(TypedDict):
    key: str
    type: str
    title: str
    active: bool
    filter_: NotRequired[List[GetLibraryItemsLibraryFilterTypedDict]]
    sort: NotRequired[List[GetLibraryItemsLibrarySortTypedDict]]
    field: NotRequired[List[GetLibraryItemsLibraryFieldTypedDict]]


class GetLibraryItemsLibraryResponseType(BaseModel):
    key: str

    type: str

    title: str

    active: bool

    filter_: Annotated[
        Optional[List[GetLibraryItemsLibraryFilter]], pydantic.Field(alias="Filter")
    ] = None

    sort: Annotated[
        Optional[List[GetLibraryItemsLibrarySort]], pydantic.Field(alias="Sort")
    ] = None

    field: Annotated[
        Optional[List[GetLibraryItemsLibraryField]], pydantic.Field(alias="Field")
    ] = None


class GetLibraryItemsLibraryOperatorTypedDict(TypedDict):
    key: str
    title: str


class GetLibraryItemsLibraryOperator(BaseModel):
    key: str

    title: str


class GetLibraryItemsLibraryFieldTypeTypedDict(TypedDict):
    type: str
    operator: List[GetLibraryItemsLibraryOperatorTypedDict]


class GetLibraryItemsLibraryFieldType(BaseModel):
    type: str

    operator: Annotated[
        List[GetLibraryItemsLibraryOperator], pydantic.Field(alias="Operator")
    ]


class GetLibraryItemsMetaTypedDict(TypedDict):
    r"""The Meta object is only included in the response if the `includeMeta` parameter is set to `1`."""

    type: NotRequired[List[GetLibraryItemsLibraryResponseTypeTypedDict]]
    field_type: NotRequired[List[GetLibraryItemsLibraryFieldTypeTypedDict]]


class GetLibraryItemsMeta(BaseModel):
    r"""The Meta object is only included in the response if the `includeMeta` parameter is set to `1`."""

    type: Annotated[
        Optional[List[GetLibraryItemsLibraryResponseType]], pydantic.Field(alias="Type")
    ] = None

    field_type: Annotated[
        Optional[List[GetLibraryItemsLibraryFieldType]],
        pydantic.Field(alias="FieldType"),
    ] = None


class GetLibraryItemsMediaContainerTypedDict(TypedDict):
    r"""The Meta object is only included in the response if the `includeMeta` parameter is set to `1`."""

    size: int
    total_size: int
    offset: int
    content: str
    allow_sync: bool
    art: str
    identifier: str
    library_section_id: int
    library_section_title: str
    library_section_uuid: str
    media_tag_prefix: str
    media_tag_version: int
    thumb: str
    title1: str
    title2: str
    view_group: str
    type: NotRequired[List[GetLibraryItemsTypeTypedDict]]
    field_type: NotRequired[List[GetLibraryItemsFieldTypeTypedDict]]
    nocache: NotRequired[bool]
    view_mode: NotRequired[int]
    mixed_parents: NotRequired[bool]
    metadata: NotRequired[List[GetLibraryItemsMetadataTypedDict]]
    meta: NotRequired[GetLibraryItemsMetaTypedDict]
    r"""The Meta object is only included in the response if the `includeMeta` parameter is set to `1`.

    """


class GetLibraryItemsMediaContainer(BaseModel):
    r"""The Meta object is only included in the response if the `includeMeta` parameter is set to `1`."""

    size: int

    total_size: Annotated[int, pydantic.Field(alias="totalSize")]

    offset: int

    content: str

    allow_sync: Annotated[bool, pydantic.Field(alias="allowSync")]

    art: str

    identifier: str

    library_section_id: Annotated[int, pydantic.Field(alias="librarySectionID")]

    library_section_title: Annotated[str, pydantic.Field(alias="librarySectionTitle")]

    library_section_uuid: Annotated[str, pydantic.Field(alias="librarySectionUUID")]

    media_tag_prefix: Annotated[str, pydantic.Field(alias="mediaTagPrefix")]

    media_tag_version: Annotated[int, pydantic.Field(alias="mediaTagVersion")]

    thumb: str

    title1: str

    title2: str

    view_group: Annotated[str, pydantic.Field(alias="viewGroup")]

    type: Annotated[
        Optional[List[GetLibraryItemsType]], pydantic.Field(alias="Type")
    ] = None

    field_type: Annotated[
        Optional[List[GetLibraryItemsFieldType]], pydantic.Field(alias="FieldType")
    ] = None

    nocache: Optional[bool] = None

    view_mode: Annotated[Optional[int], pydantic.Field(alias="viewMode")] = None

    mixed_parents: Annotated[Optional[bool], pydantic.Field(alias="mixedParents")] = (
        None
    )

    metadata: Annotated[
        Optional[List[GetLibraryItemsMetadata]], pydantic.Field(alias="Metadata")
    ] = None

    meta: Annotated[Optional[GetLibraryItemsMeta], pydantic.Field(alias="Meta")] = None
    r"""The Meta object is only included in the response if the `includeMeta` parameter is set to `1`.

    """


class GetLibraryItemsResponseBodyTypedDict(TypedDict):
    r"""The contents of the library by section and tag"""

    media_container: NotRequired[GetLibraryItemsMediaContainerTypedDict]


class GetLibraryItemsResponseBody(BaseModel):
    r"""The contents of the library by section and tag"""

    media_container: Annotated[
        Optional[GetLibraryItemsMediaContainer], pydantic.Field(alias="MediaContainer")
    ] = None


class GetLibraryItemsResponseTypedDict(TypedDict):
    content_type: str
    r"""HTTP response content type for this operation"""
    status_code: int
    r"""HTTP response status code for this operation"""
    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""
    object: NotRequired[GetLibraryItemsResponseBodyTypedDict]
    r"""The contents of the library by section and tag"""


class GetLibraryItemsResponse(BaseModel):
    content_type: str
    r"""HTTP response content type for this operation"""

    status_code: int
    r"""HTTP response status code for this operation"""

    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""

    object: Optional[GetLibraryItemsResponseBody] = None
    r"""The contents of the library by section and tag"""
