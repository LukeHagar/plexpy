"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import date
from enum import Enum
import httpx
from plex_api_client import utils
from plex_api_client.types import BaseModel
from plex_api_client.utils import (
    FieldMetadata,
    PathParamMetadata,
    QueryParamMetadata,
    validate_open_enum,
)
import pydantic
from pydantic.functional_validators import PlainValidator
from typing import List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class GetMediaMetaDataRequestTypedDict(TypedDict):
    rating_key: int
    r"""the id of the library item to return the children of."""
    include_concerts: NotRequired[bool]
    r"""Include concerts data if set to true."""
    include_extras: NotRequired[bool]
    r"""Include extra content (e.g. bonus features)."""
    include_on_deck: NotRequired[bool]
    r"""Include on-deck items."""
    include_popular_leaves: NotRequired[bool]
    r"""Include popular leaves (episodes/chapters)."""
    include_preferences: NotRequired[bool]
    r"""Include preferences information."""
    include_reviews: NotRequired[bool]
    r"""Include reviews for the content."""
    include_chapters: NotRequired[bool]
    r"""Include chapter details."""
    include_stations: NotRequired[bool]
    r"""Include station data."""
    include_external_media: NotRequired[bool]
    r"""Include external media data."""
    async_augment_metadata: NotRequired[bool]
    r"""Trigger asynchronous metadata augmentation."""
    async_check_files: NotRequired[bool]
    r"""Trigger asynchronous file checking."""
    async_refresh_analysis: NotRequired[bool]
    r"""Trigger asynchronous refresh of analysis."""
    async_refresh_local_media_agent: NotRequired[bool]
    r"""Trigger asynchronous refresh of the local media agent."""


class GetMediaMetaDataRequest(BaseModel):
    rating_key: Annotated[
        int,
        pydantic.Field(alias="ratingKey"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""the id of the library item to return the children of."""

    include_concerts: Annotated[
        Optional[bool],
        pydantic.Field(alias="includeConcerts"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Include concerts data if set to true."""

    include_extras: Annotated[
        Optional[bool],
        pydantic.Field(alias="includeExtras"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Include extra content (e.g. bonus features)."""

    include_on_deck: Annotated[
        Optional[bool],
        pydantic.Field(alias="includeOnDeck"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Include on-deck items."""

    include_popular_leaves: Annotated[
        Optional[bool],
        pydantic.Field(alias="includePopularLeaves"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Include popular leaves (episodes/chapters)."""

    include_preferences: Annotated[
        Optional[bool],
        pydantic.Field(alias="includePreferences"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Include preferences information."""

    include_reviews: Annotated[
        Optional[bool],
        pydantic.Field(alias="includeReviews"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Include reviews for the content."""

    include_chapters: Annotated[
        Optional[bool],
        pydantic.Field(alias="includeChapters"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Include chapter details."""

    include_stations: Annotated[
        Optional[bool],
        pydantic.Field(alias="includeStations"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Include station data."""

    include_external_media: Annotated[
        Optional[bool],
        pydantic.Field(alias="includeExternalMedia"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Include external media data."""

    async_augment_metadata: Annotated[
        Optional[bool],
        pydantic.Field(alias="asyncAugmentMetadata"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Trigger asynchronous metadata augmentation."""

    async_check_files: Annotated[
        Optional[bool],
        pydantic.Field(alias="asyncCheckFiles"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Trigger asynchronous file checking."""

    async_refresh_analysis: Annotated[
        Optional[bool],
        pydantic.Field(alias="asyncRefreshAnalysis"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Trigger asynchronous refresh of analysis."""

    async_refresh_local_media_agent: Annotated[
        Optional[bool],
        pydantic.Field(alias="asyncRefreshLocalMediaAgent"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Trigger asynchronous refresh of the local media agent."""


class GetMediaMetaDataType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The type of media content"""

    MOVIE = "movie"
    TV_SHOW = "show"
    SEASON = "season"
    EPISODE = "episode"
    ARTIST = "artist"
    ALBUM = "album"


class GetMediaMetaDataLibraryType(str, Enum, metaclass=utils.OpenEnumMeta):
    COVER_POSTER = "coverPoster"
    BACKGROUND = "background"
    SNAPSHOT = "snapshot"
    CLEAR_LOGO = "clearLogo"


class GetMediaMetaDataImageTypedDict(TypedDict):
    alt: str
    type: GetMediaMetaDataLibraryType
    url: str


class GetMediaMetaDataImage(BaseModel):
    alt: str

    type: Annotated[
        GetMediaMetaDataLibraryType, PlainValidator(validate_open_enum(False))
    ]

    url: str


class GetMediaMetaDataUltraBlurColorsTypedDict(TypedDict):
    top_left: str
    top_right: str
    bottom_right: str
    bottom_left: str


class GetMediaMetaDataUltraBlurColors(BaseModel):
    top_left: Annotated[str, pydantic.Field(alias="topLeft")]

    top_right: Annotated[str, pydantic.Field(alias="topRight")]

    bottom_right: Annotated[str, pydantic.Field(alias="bottomRight")]

    bottom_left: Annotated[str, pydantic.Field(alias="bottomLeft")]


class GetMediaMetaDataOptimizedForStreaming1(int, Enum):
    ZERO = 0
    ONE = 1


GetMediaMetaDataOptimizedForStreamingTypedDict = TypeAliasType(
    "GetMediaMetaDataOptimizedForStreamingTypedDict",
    Union[GetMediaMetaDataOptimizedForStreaming1, bool],
)
r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""


GetMediaMetaDataOptimizedForStreaming = TypeAliasType(
    "GetMediaMetaDataOptimizedForStreaming",
    Union[GetMediaMetaDataOptimizedForStreaming1, bool],
)
r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""


class GetMediaMetaDataOptimizedForStreamingLibrary1(int, Enum):
    ZERO = 0
    ONE = 1


GetMediaMetaDataLibraryOptimizedForStreamingTypedDict = TypeAliasType(
    "GetMediaMetaDataLibraryOptimizedForStreamingTypedDict",
    Union[GetMediaMetaDataOptimizedForStreamingLibrary1, bool],
)
r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""


GetMediaMetaDataLibraryOptimizedForStreaming = TypeAliasType(
    "GetMediaMetaDataLibraryOptimizedForStreaming",
    Union[GetMediaMetaDataOptimizedForStreamingLibrary1, bool],
)
r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""


class GetMediaMetaDataHasThumbnail(str, Enum):
    r"""Indicates if the part has a thumbnail."""

    FALSE = "0"
    TRUE = "1"


class GetMediaMetaDataStreamType(int, Enum, metaclass=utils.OpenEnumMeta):
    r"""Stream type:
    - 1 = video
    - 2 = audio
    - 3 = subtitle

    """

    VIDEO = 1
    AUDIO = 2
    SUBTITLE = 3


class GetMediaMetaDataStreamTypedDict(TypedDict):
    id: int
    r"""Unique stream identifier."""
    stream_type: GetMediaMetaDataStreamType
    r"""Stream type:
    - 1 = video
    - 2 = audio
    - 3 = subtitle

    """
    codec: str
    r"""Codec used by the stream."""
    display_title: str
    r"""Display title for the stream."""
    extended_display_title: str
    r"""Extended display title for the stream."""
    format_: NotRequired[str]
    r"""Format of the stream (e.g., srt)."""
    default: NotRequired[bool]
    r"""Indicates if this stream is default."""
    index: NotRequired[int]
    r"""Index of the stream."""
    bitrate: NotRequired[int]
    r"""Bitrate of the stream."""
    language: NotRequired[str]
    r"""Language of the stream."""
    language_tag: NotRequired[str]
    r"""Language tag (e.g., en)."""
    language_code: NotRequired[str]
    r"""ISO language code."""
    header_compression: NotRequired[bool]
    r"""Indicates whether header compression is enabled."""
    dovibl_compat_id: NotRequired[int]
    r"""Dolby Vision BL compatibility ID."""
    dovibl_present: NotRequired[bool]
    r"""Indicates if Dolby Vision BL is present."""
    doviel_present: NotRequired[bool]
    r"""Indicates if Dolby Vision EL is present."""
    dovi_level: NotRequired[int]
    r"""Dolby Vision level."""
    dovi_present: NotRequired[bool]
    r"""Indicates if Dolby Vision is present."""
    dovi_profile: NotRequired[int]
    r"""Dolby Vision profile."""
    dovirpu_present: NotRequired[bool]
    r"""Indicates if Dolby Vision RPU is present."""
    dovi_version: NotRequired[str]
    r"""Dolby Vision version."""
    bit_depth: NotRequired[int]
    r"""Bit depth of the video stream."""
    chroma_location: NotRequired[str]
    r"""Chroma sample location."""
    chroma_subsampling: NotRequired[str]
    r"""Chroma subsampling format."""
    coded_height: NotRequired[int]
    r"""Coded video height."""
    coded_width: NotRequired[int]
    r"""Coded video width."""
    closed_captions: NotRequired[bool]
    color_primaries: NotRequired[str]
    r"""Color primaries used."""
    color_range: NotRequired[str]
    r"""Color range (e.g., tv)."""
    color_space: NotRequired[str]
    r"""Color space."""
    color_trc: NotRequired[str]
    r"""Color transfer characteristics."""
    frame_rate: NotRequired[float]
    r"""Frame rate of the stream."""
    key: NotRequired[str]
    r"""Key to access this stream part."""
    height: NotRequired[int]
    r"""Height of the video stream."""
    level: NotRequired[int]
    r"""Video level."""
    original: NotRequired[bool]
    r"""Indicates if this is the original stream."""
    has_scaling_matrix: NotRequired[bool]
    profile: NotRequired[str]
    r"""Video profile."""
    scan_type: NotRequired[str]
    embedded_in_video: NotRequired[str]
    ref_frames: NotRequired[int]
    r"""Number of reference frames."""
    width: NotRequired[int]
    r"""Width of the video stream."""
    selected: NotRequired[bool]
    r"""Indicates if this stream is selected (applicable for audio streams)."""
    forced: NotRequired[bool]
    channels: NotRequired[int]
    r"""Number of audio channels (for audio streams)."""
    audio_channel_layout: NotRequired[str]
    r"""Audio channel layout."""
    sampling_rate: NotRequired[int]
    r"""Sampling rate for the audio stream."""
    can_auto_sync: NotRequired[bool]
    r"""Indicates if the stream can auto-sync."""
    hearing_impaired: NotRequired[bool]
    r"""Indicates if the stream is for the hearing impaired."""
    dub: NotRequired[bool]
    r"""Indicates if the stream is a dub."""
    title: NotRequired[str]
    r"""Optional title for the stream (e.g., language variant)."""


class GetMediaMetaDataStream(BaseModel):
    id: int
    r"""Unique stream identifier."""

    stream_type: Annotated[
        Annotated[GetMediaMetaDataStreamType, PlainValidator(validate_open_enum(True))],
        pydantic.Field(alias="streamType"),
    ]
    r"""Stream type:
    - 1 = video
    - 2 = audio
    - 3 = subtitle

    """

    codec: str
    r"""Codec used by the stream."""

    display_title: Annotated[str, pydantic.Field(alias="displayTitle")]
    r"""Display title for the stream."""

    extended_display_title: Annotated[str, pydantic.Field(alias="extendedDisplayTitle")]
    r"""Extended display title for the stream."""

    format_: Annotated[Optional[str], pydantic.Field(alias="format")] = None
    r"""Format of the stream (e.g., srt)."""

    default: Optional[bool] = None
    r"""Indicates if this stream is default."""

    index: Optional[int] = None
    r"""Index of the stream."""

    bitrate: Optional[int] = None
    r"""Bitrate of the stream."""

    language: Optional[str] = None
    r"""Language of the stream."""

    language_tag: Annotated[Optional[str], pydantic.Field(alias="languageTag")] = None
    r"""Language tag (e.g., en)."""

    language_code: Annotated[Optional[str], pydantic.Field(alias="languageCode")] = None
    r"""ISO language code."""

    header_compression: Annotated[
        Optional[bool], pydantic.Field(alias="headerCompression")
    ] = None
    r"""Indicates whether header compression is enabled."""

    dovibl_compat_id: Annotated[
        Optional[int], pydantic.Field(alias="DOVIBLCompatID")
    ] = None
    r"""Dolby Vision BL compatibility ID."""

    dovibl_present: Annotated[Optional[bool], pydantic.Field(alias="DOVIBLPresent")] = (
        None
    )
    r"""Indicates if Dolby Vision BL is present."""

    doviel_present: Annotated[Optional[bool], pydantic.Field(alias="DOVIELPresent")] = (
        None
    )
    r"""Indicates if Dolby Vision EL is present."""

    dovi_level: Annotated[Optional[int], pydantic.Field(alias="DOVILevel")] = None
    r"""Dolby Vision level."""

    dovi_present: Annotated[Optional[bool], pydantic.Field(alias="DOVIPresent")] = None
    r"""Indicates if Dolby Vision is present."""

    dovi_profile: Annotated[Optional[int], pydantic.Field(alias="DOVIProfile")] = None
    r"""Dolby Vision profile."""

    dovirpu_present: Annotated[
        Optional[bool], pydantic.Field(alias="DOVIRPUPresent")
    ] = None
    r"""Indicates if Dolby Vision RPU is present."""

    dovi_version: Annotated[Optional[str], pydantic.Field(alias="DOVIVersion")] = None
    r"""Dolby Vision version."""

    bit_depth: Annotated[Optional[int], pydantic.Field(alias="bitDepth")] = None
    r"""Bit depth of the video stream."""

    chroma_location: Annotated[
        Optional[str], pydantic.Field(alias="chromaLocation")
    ] = None
    r"""Chroma sample location."""

    chroma_subsampling: Annotated[
        Optional[str], pydantic.Field(alias="chromaSubsampling")
    ] = None
    r"""Chroma subsampling format."""

    coded_height: Annotated[Optional[int], pydantic.Field(alias="codedHeight")] = None
    r"""Coded video height."""

    coded_width: Annotated[Optional[int], pydantic.Field(alias="codedWidth")] = None
    r"""Coded video width."""

    closed_captions: Annotated[
        Optional[bool], pydantic.Field(alias="closedCaptions")
    ] = None

    color_primaries: Annotated[
        Optional[str], pydantic.Field(alias="colorPrimaries")
    ] = None
    r"""Color primaries used."""

    color_range: Annotated[Optional[str], pydantic.Field(alias="colorRange")] = None
    r"""Color range (e.g., tv)."""

    color_space: Annotated[Optional[str], pydantic.Field(alias="colorSpace")] = None
    r"""Color space."""

    color_trc: Annotated[Optional[str], pydantic.Field(alias="colorTrc")] = None
    r"""Color transfer characteristics."""

    frame_rate: Annotated[Optional[float], pydantic.Field(alias="frameRate")] = None
    r"""Frame rate of the stream."""

    key: Optional[str] = None
    r"""Key to access this stream part."""

    height: Optional[int] = None
    r"""Height of the video stream."""

    level: Optional[int] = None
    r"""Video level."""

    original: Optional[bool] = None
    r"""Indicates if this is the original stream."""

    has_scaling_matrix: Annotated[
        Optional[bool], pydantic.Field(alias="hasScalingMatrix")
    ] = None

    profile: Optional[str] = None
    r"""Video profile."""

    scan_type: Annotated[Optional[str], pydantic.Field(alias="scanType")] = None

    embedded_in_video: Annotated[
        Optional[str], pydantic.Field(alias="embeddedInVideo")
    ] = None

    ref_frames: Annotated[Optional[int], pydantic.Field(alias="refFrames")] = None
    r"""Number of reference frames."""

    width: Optional[int] = None
    r"""Width of the video stream."""

    selected: Optional[bool] = None
    r"""Indicates if this stream is selected (applicable for audio streams)."""

    forced: Optional[bool] = None

    channels: Optional[int] = None
    r"""Number of audio channels (for audio streams)."""

    audio_channel_layout: Annotated[
        Optional[str], pydantic.Field(alias="audioChannelLayout")
    ] = None
    r"""Audio channel layout."""

    sampling_rate: Annotated[Optional[int], pydantic.Field(alias="samplingRate")] = None
    r"""Sampling rate for the audio stream."""

    can_auto_sync: Annotated[Optional[bool], pydantic.Field(alias="canAutoSync")] = None
    r"""Indicates if the stream can auto-sync."""

    hearing_impaired: Annotated[
        Optional[bool], pydantic.Field(alias="hearingImpaired")
    ] = None
    r"""Indicates if the stream is for the hearing impaired."""

    dub: Optional[bool] = None
    r"""Indicates if the stream is a dub."""

    title: Optional[str] = None
    r"""Optional title for the stream (e.g., language variant)."""


class GetMediaMetaDataPartTypedDict(TypedDict):
    id: int
    r"""Unique part identifier."""
    key: str
    r"""Key to access this part."""
    file: str
    r"""File path for the part."""
    size: int
    r"""File size in bytes."""
    accessible: NotRequired[bool]
    r"""Indicates if the part is accessible."""
    exists: NotRequired[bool]
    r"""Indicates if the part exists."""
    indexes: NotRequired[str]
    duration: NotRequired[int]
    r"""Duration of the part in milliseconds."""
    packet_length: NotRequired[int]
    container: NotRequired[str]
    r"""Container format of the part."""
    video_profile: NotRequired[str]
    r"""Video profile for the part."""
    audio_profile: NotRequired[str]
    r"""The audio profile used for the media (e.g., DTS, Dolby Digital, etc.)."""
    has64bit_offsets: NotRequired[bool]
    optimized_for_streaming: NotRequired[
        GetMediaMetaDataLibraryOptimizedForStreamingTypedDict
    ]
    r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""
    has_thumbnail: NotRequired[GetMediaMetaDataHasThumbnail]
    stream: NotRequired[List[GetMediaMetaDataStreamTypedDict]]
    r"""An array of streams for this part."""


class GetMediaMetaDataPart(BaseModel):
    id: int
    r"""Unique part identifier."""

    key: str
    r"""Key to access this part."""

    file: str
    r"""File path for the part."""

    size: int
    r"""File size in bytes."""

    accessible: Optional[bool] = None
    r"""Indicates if the part is accessible."""

    exists: Optional[bool] = None
    r"""Indicates if the part exists."""

    indexes: Optional[str] = None

    duration: Optional[int] = None
    r"""Duration of the part in milliseconds."""

    packet_length: Annotated[Optional[int], pydantic.Field(alias="packetLength")] = None

    container: Optional[str] = None
    r"""Container format of the part."""

    video_profile: Annotated[Optional[str], pydantic.Field(alias="videoProfile")] = None
    r"""Video profile for the part."""

    audio_profile: Annotated[Optional[str], pydantic.Field(alias="audioProfile")] = None
    r"""The audio profile used for the media (e.g., DTS, Dolby Digital, etc.)."""

    has64bit_offsets: Annotated[
        Optional[bool], pydantic.Field(alias="has64bitOffsets")
    ] = None

    optimized_for_streaming: Annotated[
        Optional[GetMediaMetaDataLibraryOptimizedForStreaming],
        pydantic.Field(alias="optimizedForStreaming"),
    ] = None
    r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""

    has_thumbnail: Annotated[
        Optional[GetMediaMetaDataHasThumbnail], pydantic.Field(alias="hasThumbnail")
    ] = GetMediaMetaDataHasThumbnail.FALSE

    stream: Annotated[
        Optional[List[GetMediaMetaDataStream]], pydantic.Field(alias="Stream")
    ] = None
    r"""An array of streams for this part."""


class GetMediaMetaDataMediaTypedDict(TypedDict):
    id: int
    r"""Unique media identifier."""
    duration: NotRequired[int]
    r"""Duration of the media in milliseconds."""
    bitrate: NotRequired[int]
    r"""Bitrate in bits per second."""
    width: NotRequired[int]
    r"""Video width in pixels."""
    height: NotRequired[int]
    r"""Video height in pixels."""
    aspect_ratio: NotRequired[float]
    r"""Aspect ratio of the video."""
    audio_channels: NotRequired[int]
    r"""Number of audio channels."""
    display_offset: NotRequired[int]
    audio_codec: NotRequired[str]
    r"""Audio codec used."""
    video_codec: NotRequired[str]
    r"""Video codec used."""
    video_resolution: NotRequired[str]
    r"""Video resolution (e.g., 4k)."""
    container: NotRequired[str]
    r"""File container type."""
    video_frame_rate: NotRequired[str]
    r"""Frame rate of the video. Values found include NTSC, PAL, 24p

    """
    video_profile: NotRequired[str]
    r"""Video profile (e.g., main 10)."""
    has_voice_activity: NotRequired[bool]
    r"""Indicates whether voice activity is detected."""
    audio_profile: NotRequired[str]
    r"""The audio profile used for the media (e.g., DTS, Dolby Digital, etc.)."""
    optimized_for_streaming: NotRequired[GetMediaMetaDataOptimizedForStreamingTypedDict]
    r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""
    has64bit_offsets: NotRequired[bool]
    part: NotRequired[List[GetMediaMetaDataPartTypedDict]]
    r"""An array of parts for this media item."""


class GetMediaMetaDataMedia(BaseModel):
    id: int
    r"""Unique media identifier."""

    duration: Optional[int] = None
    r"""Duration of the media in milliseconds."""

    bitrate: Optional[int] = None
    r"""Bitrate in bits per second."""

    width: Optional[int] = None
    r"""Video width in pixels."""

    height: Optional[int] = None
    r"""Video height in pixels."""

    aspect_ratio: Annotated[Optional[float], pydantic.Field(alias="aspectRatio")] = None
    r"""Aspect ratio of the video."""

    audio_channels: Annotated[Optional[int], pydantic.Field(alias="audioChannels")] = (
        None
    )
    r"""Number of audio channels."""

    display_offset: Annotated[Optional[int], pydantic.Field(alias="displayOffset")] = (
        None
    )

    audio_codec: Annotated[Optional[str], pydantic.Field(alias="audioCodec")] = None
    r"""Audio codec used."""

    video_codec: Annotated[Optional[str], pydantic.Field(alias="videoCodec")] = None
    r"""Video codec used."""

    video_resolution: Annotated[
        Optional[str], pydantic.Field(alias="videoResolution")
    ] = None
    r"""Video resolution (e.g., 4k)."""

    container: Optional[str] = None
    r"""File container type."""

    video_frame_rate: Annotated[
        Optional[str], pydantic.Field(alias="videoFrameRate")
    ] = None
    r"""Frame rate of the video. Values found include NTSC, PAL, 24p

    """

    video_profile: Annotated[Optional[str], pydantic.Field(alias="videoProfile")] = None
    r"""Video profile (e.g., main 10)."""

    has_voice_activity: Annotated[
        Optional[bool], pydantic.Field(alias="hasVoiceActivity")
    ] = None
    r"""Indicates whether voice activity is detected."""

    audio_profile: Annotated[Optional[str], pydantic.Field(alias="audioProfile")] = None
    r"""The audio profile used for the media (e.g., DTS, Dolby Digital, etc.)."""

    optimized_for_streaming: Annotated[
        Optional[GetMediaMetaDataOptimizedForStreaming],
        pydantic.Field(alias="optimizedForStreaming"),
    ] = None
    r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""

    has64bit_offsets: Annotated[
        Optional[bool], pydantic.Field(alias="has64bitOffsets")
    ] = None

    part: Annotated[
        Optional[List[GetMediaMetaDataPart]], pydantic.Field(alias="Part")
    ] = None
    r"""An array of parts for this media item."""


class GetMediaMetaDataGenreTypedDict(TypedDict):
    r"""The filter query string for similar items."""

    id: int
    tag: str
    r"""The genre name of this media-item

    """
    filter_: str


class GetMediaMetaDataGenre(BaseModel):
    r"""The filter query string for similar items."""

    id: int

    tag: str
    r"""The genre name of this media-item

    """

    filter_: Annotated[str, pydantic.Field(alias="filter")]


class GetMediaMetaDataCountryTypedDict(TypedDict):
    r"""The filter query string for country media items."""

    id: int
    tag: str
    r"""The country of origin of this media item"""
    filter_: NotRequired[str]


class GetMediaMetaDataCountry(BaseModel):
    r"""The filter query string for country media items."""

    id: int

    tag: str
    r"""The country of origin of this media item"""

    filter_: Annotated[Optional[str], pydantic.Field(alias="filter")] = None


class GetMediaMetaDataDirectorTypedDict(TypedDict):
    id: int
    r"""Unique identifier for the director."""
    tag: str
    r"""The role of Director"""
    filter_: str
    r"""The filter string used to query this director."""
    tag_key: NotRequired[str]
    r"""A unique key associated with the director's tag, used for internal identification."""
    thumb: NotRequired[str]
    r"""The URL of the thumbnail image for the director."""


class GetMediaMetaDataDirector(BaseModel):
    id: int
    r"""Unique identifier for the director."""

    tag: str
    r"""The role of Director"""

    filter_: Annotated[str, pydantic.Field(alias="filter")]
    r"""The filter string used to query this director."""

    tag_key: Annotated[Optional[str], pydantic.Field(alias="tagKey")] = None
    r"""A unique key associated with the director's tag, used for internal identification."""

    thumb: Optional[str] = None
    r"""The URL of the thumbnail image for the director."""


class GetMediaMetaDataWriterTypedDict(TypedDict):
    id: int
    r"""Unique identifier for the writer."""
    tag: str
    r"""The role of Writer"""
    filter_: str
    r"""The filter string used to query this writer."""
    thumb: NotRequired[str]
    r"""The URL of the thumbnail image for the writer."""
    tag_key: NotRequired[str]
    r"""A unique key associated with the writers tag, used for internal identification."""


class GetMediaMetaDataWriter(BaseModel):
    id: int
    r"""Unique identifier for the writer."""

    tag: str
    r"""The role of Writer"""

    filter_: Annotated[str, pydantic.Field(alias="filter")]
    r"""The filter string used to query this writer."""

    thumb: Optional[str] = None
    r"""The URL of the thumbnail image for the writer."""

    tag_key: Annotated[Optional[str], pydantic.Field(alias="tagKey")] = None
    r"""A unique key associated with the writers tag, used for internal identification."""


class GetMediaMetaDataProducerTypedDict(TypedDict):
    id: int
    r"""The unique role identifier."""
    filter_: str
    r"""The filter string for the role."""
    tag: str
    r"""The actor's name."""
    tag_key: str
    r"""A key associated with the actor tag."""
    role: NotRequired[str]
    r"""The character name or role."""
    thumb: NotRequired[str]
    r"""URL for the role thumbnail image."""


class GetMediaMetaDataProducer(BaseModel):
    id: int
    r"""The unique role identifier."""

    filter_: Annotated[str, pydantic.Field(alias="filter")]
    r"""The filter string for the role."""

    tag: str
    r"""The actor's name."""

    tag_key: Annotated[str, pydantic.Field(alias="tagKey")]
    r"""A key associated with the actor tag."""

    role: Optional[str] = None
    r"""The character name or role."""

    thumb: Optional[str] = None
    r"""URL for the role thumbnail image."""


class GetMediaMetaDataRoleTypedDict(TypedDict):
    id: int
    r"""Unique identifier for the actor or role."""
    tag: str
    r"""The display tag for the actor (typically the actor's name)."""
    filter_: str
    r"""The filter string used to query this actor. For example, it may indicate that this is an actor with a given key."""
    role: NotRequired[str]
    r"""The role played by the actor in the media item."""
    tag_key: NotRequired[str]
    r"""A unique key associated with the actor's tag, used for internal identification."""
    thumb: NotRequired[str]
    r"""The URL of the thumbnail image for the actor."""


class GetMediaMetaDataRole(BaseModel):
    id: int
    r"""Unique identifier for the actor or role."""

    tag: str
    r"""The display tag for the actor (typically the actor's name)."""

    filter_: Annotated[str, pydantic.Field(alias="filter")]
    r"""The filter string used to query this actor. For example, it may indicate that this is an actor with a given key."""

    role: Optional[str] = None
    r"""The role played by the actor in the media item."""

    tag_key: Annotated[Optional[str], pydantic.Field(alias="tagKey")] = None
    r"""A unique key associated with the actor's tag, used for internal identification."""

    thumb: Optional[str] = None
    r"""The URL of the thumbnail image for the actor."""


class GetMediaMetaDataGuidsTypedDict(TypedDict):
    id: str
    r"""The GUID value."""


class GetMediaMetaDataGuids(BaseModel):
    id: str
    r"""The GUID value."""


class RatingsTypedDict(TypedDict):
    image: str
    r"""The image or reference for the rating."""
    value: float
    r"""The rating value."""
    type: str
    r"""The type of rating (e.g., audience, critic)."""


class Ratings(BaseModel):
    image: str
    r"""The image or reference for the rating."""

    value: float
    r"""The rating value."""

    type: str
    r"""The type of rating (e.g., audience, critic)."""


class GetMediaMetaDataSimilarTypedDict(TypedDict):
    id: int
    r"""The unique similar item identifier."""
    filter_: str
    r"""The filter string for similar items."""
    tag: str
    r"""The tag or title of the similar content."""


class GetMediaMetaDataSimilar(BaseModel):
    id: int
    r"""The unique similar item identifier."""

    filter_: Annotated[str, pydantic.Field(alias="filter")]
    r"""The filter string for similar items."""

    tag: str
    r"""The tag or title of the similar content."""


class GetMediaMetaDataLocationTypedDict(TypedDict):
    path: str
    r"""The file path for the location."""


class GetMediaMetaDataLocation(BaseModel):
    path: str
    r"""The file path for the location."""


class ChapterTypedDict(TypedDict):
    r"""The thumbnail for the chapter"""

    id: int
    filter_: str
    index: int
    start_time_offset: int
    end_time_offset: int
    thumb: str


class Chapter(BaseModel):
    r"""The thumbnail for the chapter"""

    id: int

    filter_: Annotated[str, pydantic.Field(alias="filter")]

    index: int

    start_time_offset: Annotated[int, pydantic.Field(alias="startTimeOffset")]

    end_time_offset: Annotated[int, pydantic.Field(alias="endTimeOffset")]

    thumb: str


class AttributesTypedDict(TypedDict):
    r"""Attributes associated with the marker."""

    id: int
    r"""The identifier for the attributes."""
    version: NotRequired[int]
    r"""The version number of the marker attributes."""


class Attributes(BaseModel):
    r"""Attributes associated with the marker."""

    id: int
    r"""The identifier for the attributes."""

    version: Optional[int] = None
    r"""The version number of the marker attributes."""


class MarkerTypedDict(TypedDict):
    r"""The final status of the marker"""

    id: int
    type: str
    start_time_offset: int
    end_time_offset: int
    final: NotRequired[bool]
    attributes: NotRequired[AttributesTypedDict]
    r"""Attributes associated with the marker."""


class Marker(BaseModel):
    r"""The final status of the marker"""

    id: int

    type: str

    start_time_offset: Annotated[int, pydantic.Field(alias="startTimeOffset")]

    end_time_offset: Annotated[int, pydantic.Field(alias="endTimeOffset")]

    final: Optional[bool] = None

    attributes: Annotated[Optional[Attributes], pydantic.Field(alias="Attributes")] = (
        None
    )
    r"""Attributes associated with the marker."""


class ExtrasTypedDict(TypedDict):
    size: NotRequired[int]
    r"""The size of the extras."""


class Extras(BaseModel):
    size: Optional[int] = None
    r"""The size of the extras."""


class GetMediaMetaDataMetadataTypedDict(TypedDict):
    r"""Unknown"""

    rating_key: str
    r"""The rating key (Media ID) of this media item. Note: Although this is always an integer, it is represented as a string in the API."""
    key: str
    r"""The unique key for the media item."""
    guid: str
    r"""The globally unique identifier for the media item."""
    slug: str
    r"""A URL‐friendly version of the media title."""
    type: GetMediaMetaDataType
    title: str
    r"""The title of the media item."""
    title_sort: str
    r"""The sort title used for ordering media items."""
    summary: str
    r"""A synopsis of the media item."""
    rating: float
    r"""The critic rating for the media item."""
    audience_rating: float
    r"""The audience rating for the media item."""
    tagline: str
    r"""A brief tagline for the media item."""
    thumb: str
    r"""The thumbnail image URL for the media item."""
    art: str
    r"""The art image URL for the media item."""
    theme: str
    r"""The theme URL for the media item."""
    index: int
    r"""The index position of the media item."""
    child_count: int
    r"""The number of child items associated with this media item."""
    season_count: int
    r"""The total number of seasons (for TV shows)."""
    duration: int
    r"""The duration of the media item in milliseconds."""
    originally_available_at: date
    r"""The original release date of the media item."""
    added_at: int
    library_section_id: int
    r"""The identifier for the library section."""
    library_section_title: str
    r"""The title of the library section."""
    library_section_key: str
    r"""The key corresponding to the library section."""
    studio: NotRequired[str]
    r"""The studio that produced the media item."""
    content_rating: NotRequired[str]
    r"""The content rating for the media item."""
    year: NotRequired[int]
    r"""The release year of the media item."""
    leaf_count: NotRequired[int]
    r"""The number of leaf items (end nodes) under this media item."""
    viewed_leaf_count: NotRequired[int]
    r"""The number of leaf items that have been viewed."""
    updated_at: NotRequired[int]
    r"""Unix epoch datetime in seconds"""
    audience_rating_image: NotRequired[str]
    r"""The URL for the audience rating image."""
    chapter_source: NotRequired[str]
    r"""The source from which chapter data is derived."""
    primary_extra_key: NotRequired[str]
    r"""The primary extra key associated with this media item."""
    original_title: NotRequired[str]
    r"""The original title of the media item (if different)."""
    parent_rating_key: NotRequired[str]
    r"""The rating key of the parent media item."""
    grandparent_rating_key: NotRequired[str]
    r"""The rating key of the grandparent media item."""
    parent_guid: NotRequired[str]
    r"""The GUID of the parent media item."""
    grandparent_guid: NotRequired[str]
    r"""The GUID of the grandparent media item."""
    grandparent_slug: NotRequired[str]
    r"""The slug for the grandparent media item."""
    grandparent_key: NotRequired[str]
    r"""The key of the grandparent media item."""
    parent_key: NotRequired[str]
    r"""The key of the parent media item."""
    grandparent_title: NotRequired[str]
    r"""The title of the grandparent media item."""
    grandparent_thumb: NotRequired[str]
    r"""The thumbnail URL for the grandparent media item."""
    grandparent_theme: NotRequired[str]
    r"""The theme URL for the grandparent media item."""
    grandparent_art: NotRequired[str]
    r"""The art URL for the grandparent media item."""
    parent_title: NotRequired[str]
    r"""The title of the parent media item."""
    parent_index: NotRequired[int]
    r"""The index position of the parent media item."""
    parent_thumb: NotRequired[str]
    r"""The thumbnail URL for the parent media item."""
    rating_image: NotRequired[str]
    r"""The URL for the rating image."""
    view_count: NotRequired[int]
    r"""The number of times this media item has been viewed."""
    view_offset: NotRequired[int]
    r"""The current playback offset (in milliseconds)."""
    skip_count: NotRequired[int]
    r"""The number of times this media item has been skipped."""
    subtype: NotRequired[str]
    r"""A classification that further describes the type of media item. For example, 'clip' indicates that the item is a short video clip."""
    last_rated_at: NotRequired[int]
    r"""The Unix timestamp representing the last time the item was rated."""
    created_at_accuracy: NotRequired[str]
    r"""The accuracy of the creation timestamp. This value indicates the format(s) provided (for example, 'epoch,local' means both epoch and local time formats are available)."""
    created_at_tz_offset: NotRequired[str]
    r"""The time zone offset for the creation timestamp, represented as a string. This offset indicates the difference from UTC."""
    last_viewed_at: NotRequired[int]
    r"""Unix timestamp for when the media item was last viewed."""
    user_rating: NotRequired[float]
    r"""The rating provided by a user for the item. This value is expressed as a decimal number."""
    image: NotRequired[List[GetMediaMetaDataImageTypedDict]]
    ultra_blur_colors: NotRequired[GetMediaMetaDataUltraBlurColorsTypedDict]
    media: NotRequired[List[GetMediaMetaDataMediaTypedDict]]
    genre: NotRequired[List[GetMediaMetaDataGenreTypedDict]]
    country: NotRequired[List[GetMediaMetaDataCountryTypedDict]]
    director: NotRequired[List[GetMediaMetaDataDirectorTypedDict]]
    writer: NotRequired[List[GetMediaMetaDataWriterTypedDict]]
    producer: NotRequired[List[GetMediaMetaDataProducerTypedDict]]
    role: NotRequired[List[GetMediaMetaDataRoleTypedDict]]
    guids: NotRequired[List[GetMediaMetaDataGuidsTypedDict]]
    ratings: NotRequired[List[RatingsTypedDict]]
    similar: NotRequired[List[GetMediaMetaDataSimilarTypedDict]]
    location: NotRequired[List[GetMediaMetaDataLocationTypedDict]]
    chapter: NotRequired[List[ChapterTypedDict]]
    marker: NotRequired[List[MarkerTypedDict]]
    extras: NotRequired[ExtrasTypedDict]


class GetMediaMetaDataMetadata(BaseModel):
    r"""Unknown"""

    rating_key: Annotated[str, pydantic.Field(alias="ratingKey")]
    r"""The rating key (Media ID) of this media item. Note: Although this is always an integer, it is represented as a string in the API."""

    key: str
    r"""The unique key for the media item."""

    guid: str
    r"""The globally unique identifier for the media item."""

    slug: str
    r"""A URL‐friendly version of the media title."""

    type: Annotated[GetMediaMetaDataType, PlainValidator(validate_open_enum(False))]

    title: str
    r"""The title of the media item."""

    title_sort: Annotated[str, pydantic.Field(alias="titleSort")]
    r"""The sort title used for ordering media items."""

    summary: str
    r"""A synopsis of the media item."""

    rating: float
    r"""The critic rating for the media item."""

    audience_rating: Annotated[float, pydantic.Field(alias="audienceRating")]
    r"""The audience rating for the media item."""

    tagline: str
    r"""A brief tagline for the media item."""

    thumb: str
    r"""The thumbnail image URL for the media item."""

    art: str
    r"""The art image URL for the media item."""

    theme: str
    r"""The theme URL for the media item."""

    index: int
    r"""The index position of the media item."""

    child_count: Annotated[int, pydantic.Field(alias="childCount")]
    r"""The number of child items associated with this media item."""

    season_count: Annotated[int, pydantic.Field(alias="seasonCount")]
    r"""The total number of seasons (for TV shows)."""

    duration: int
    r"""The duration of the media item in milliseconds."""

    originally_available_at: Annotated[
        date, pydantic.Field(alias="originallyAvailableAt")
    ]
    r"""The original release date of the media item."""

    added_at: Annotated[int, pydantic.Field(alias="addedAt")]

    library_section_id: Annotated[int, pydantic.Field(alias="librarySectionID")]
    r"""The identifier for the library section."""

    library_section_title: Annotated[str, pydantic.Field(alias="librarySectionTitle")]
    r"""The title of the library section."""

    library_section_key: Annotated[str, pydantic.Field(alias="librarySectionKey")]
    r"""The key corresponding to the library section."""

    studio: Optional[str] = None
    r"""The studio that produced the media item."""

    content_rating: Annotated[Optional[str], pydantic.Field(alias="contentRating")] = (
        None
    )
    r"""The content rating for the media item."""

    year: Optional[int] = None
    r"""The release year of the media item."""

    leaf_count: Annotated[Optional[int], pydantic.Field(alias="leafCount")] = None
    r"""The number of leaf items (end nodes) under this media item."""

    viewed_leaf_count: Annotated[
        Optional[int], pydantic.Field(alias="viewedLeafCount")
    ] = None
    r"""The number of leaf items that have been viewed."""

    updated_at: Annotated[Optional[int], pydantic.Field(alias="updatedAt")] = None
    r"""Unix epoch datetime in seconds"""

    audience_rating_image: Annotated[
        Optional[str], pydantic.Field(alias="audienceRatingImage")
    ] = None
    r"""The URL for the audience rating image."""

    chapter_source: Annotated[Optional[str], pydantic.Field(alias="chapterSource")] = (
        None
    )
    r"""The source from which chapter data is derived."""

    primary_extra_key: Annotated[
        Optional[str], pydantic.Field(alias="primaryExtraKey")
    ] = None
    r"""The primary extra key associated with this media item."""

    original_title: Annotated[Optional[str], pydantic.Field(alias="originalTitle")] = (
        None
    )
    r"""The original title of the media item (if different)."""

    parent_rating_key: Annotated[
        Optional[str], pydantic.Field(alias="parentRatingKey")
    ] = None
    r"""The rating key of the parent media item."""

    grandparent_rating_key: Annotated[
        Optional[str], pydantic.Field(alias="grandparentRatingKey")
    ] = None
    r"""The rating key of the grandparent media item."""

    parent_guid: Annotated[Optional[str], pydantic.Field(alias="parentGuid")] = None
    r"""The GUID of the parent media item."""

    grandparent_guid: Annotated[
        Optional[str], pydantic.Field(alias="grandparentGuid")
    ] = None
    r"""The GUID of the grandparent media item."""

    grandparent_slug: Annotated[
        Optional[str], pydantic.Field(alias="grandparentSlug")
    ] = None
    r"""The slug for the grandparent media item."""

    grandparent_key: Annotated[
        Optional[str], pydantic.Field(alias="grandparentKey")
    ] = None
    r"""The key of the grandparent media item."""

    parent_key: Annotated[Optional[str], pydantic.Field(alias="parentKey")] = None
    r"""The key of the parent media item."""

    grandparent_title: Annotated[
        Optional[str], pydantic.Field(alias="grandparentTitle")
    ] = None
    r"""The title of the grandparent media item."""

    grandparent_thumb: Annotated[
        Optional[str], pydantic.Field(alias="grandparentThumb")
    ] = None
    r"""The thumbnail URL for the grandparent media item."""

    grandparent_theme: Annotated[
        Optional[str], pydantic.Field(alias="grandparentTheme")
    ] = None
    r"""The theme URL for the grandparent media item."""

    grandparent_art: Annotated[
        Optional[str], pydantic.Field(alias="grandparentArt")
    ] = None
    r"""The art URL for the grandparent media item."""

    parent_title: Annotated[Optional[str], pydantic.Field(alias="parentTitle")] = None
    r"""The title of the parent media item."""

    parent_index: Annotated[Optional[int], pydantic.Field(alias="parentIndex")] = None
    r"""The index position of the parent media item."""

    parent_thumb: Annotated[Optional[str], pydantic.Field(alias="parentThumb")] = None
    r"""The thumbnail URL for the parent media item."""

    rating_image: Annotated[Optional[str], pydantic.Field(alias="ratingImage")] = None
    r"""The URL for the rating image."""

    view_count: Annotated[Optional[int], pydantic.Field(alias="viewCount")] = None
    r"""The number of times this media item has been viewed."""

    view_offset: Annotated[Optional[int], pydantic.Field(alias="viewOffset")] = None
    r"""The current playback offset (in milliseconds)."""

    skip_count: Annotated[Optional[int], pydantic.Field(alias="skipCount")] = None
    r"""The number of times this media item has been skipped."""

    subtype: Optional[str] = None
    r"""A classification that further describes the type of media item. For example, 'clip' indicates that the item is a short video clip."""

    last_rated_at: Annotated[Optional[int], pydantic.Field(alias="lastRatedAt")] = None
    r"""The Unix timestamp representing the last time the item was rated."""

    created_at_accuracy: Annotated[
        Optional[str], pydantic.Field(alias="createdAtAccuracy")
    ] = None
    r"""The accuracy of the creation timestamp. This value indicates the format(s) provided (for example, 'epoch,local' means both epoch and local time formats are available)."""

    created_at_tz_offset: Annotated[
        Optional[str], pydantic.Field(alias="createdAtTZOffset")
    ] = None
    r"""The time zone offset for the creation timestamp, represented as a string. This offset indicates the difference from UTC."""

    last_viewed_at: Annotated[Optional[int], pydantic.Field(alias="lastViewedAt")] = (
        None
    )
    r"""Unix timestamp for when the media item was last viewed."""

    user_rating: Annotated[Optional[float], pydantic.Field(alias="userRating")] = None
    r"""The rating provided by a user for the item. This value is expressed as a decimal number."""

    image: Annotated[
        Optional[List[GetMediaMetaDataImage]], pydantic.Field(alias="Image")
    ] = None

    ultra_blur_colors: Annotated[
        Optional[GetMediaMetaDataUltraBlurColors],
        pydantic.Field(alias="UltraBlurColors"),
    ] = None

    media: Annotated[
        Optional[List[GetMediaMetaDataMedia]], pydantic.Field(alias="Media")
    ] = None

    genre: Annotated[
        Optional[List[GetMediaMetaDataGenre]], pydantic.Field(alias="Genre")
    ] = None

    country: Annotated[
        Optional[List[GetMediaMetaDataCountry]], pydantic.Field(alias="Country")
    ] = None

    director: Annotated[
        Optional[List[GetMediaMetaDataDirector]], pydantic.Field(alias="Director")
    ] = None

    writer: Annotated[
        Optional[List[GetMediaMetaDataWriter]], pydantic.Field(alias="Writer")
    ] = None

    producer: Annotated[
        Optional[List[GetMediaMetaDataProducer]], pydantic.Field(alias="Producer")
    ] = None

    role: Annotated[
        Optional[List[GetMediaMetaDataRole]], pydantic.Field(alias="Role")
    ] = None

    guids: Annotated[
        Optional[List[GetMediaMetaDataGuids]], pydantic.Field(alias="Guid")
    ] = None

    ratings: Annotated[Optional[List[Ratings]], pydantic.Field(alias="Rating")] = None

    similar: Annotated[
        Optional[List[GetMediaMetaDataSimilar]], pydantic.Field(alias="Similar")
    ] = None

    location: Annotated[
        Optional[List[GetMediaMetaDataLocation]], pydantic.Field(alias="Location")
    ] = None

    chapter: Annotated[Optional[List[Chapter]], pydantic.Field(alias="Chapter")] = None

    marker: Annotated[Optional[List[Marker]], pydantic.Field(alias="Marker")] = None

    extras: Annotated[Optional[Extras], pydantic.Field(alias="Extras")] = None


class GetMediaMetaDataMediaContainerTypedDict(TypedDict):
    size: int
    r"""Number of media items returned in this response."""
    allow_sync: bool
    r"""Indicates whether syncing is allowed."""
    identifier: str
    r"""An plugin identifier for the media container."""
    library_section_id: int
    r"""The unique identifier for the library section."""
    library_section_title: str
    r"""The title of the library section."""
    media_tag_prefix: str
    r"""The prefix used for media tag resource paths."""
    media_tag_version: int
    r"""The version number for media tags."""
    metadata: List[GetMediaMetaDataMetadataTypedDict]
    r"""An array of metadata items."""
    library_section_uuid: NotRequired[str]
    r"""The universally unique identifier for the library section."""


class GetMediaMetaDataMediaContainer(BaseModel):
    size: int
    r"""Number of media items returned in this response."""

    allow_sync: Annotated[bool, pydantic.Field(alias="allowSync")]
    r"""Indicates whether syncing is allowed."""

    identifier: str
    r"""An plugin identifier for the media container."""

    library_section_id: Annotated[int, pydantic.Field(alias="librarySectionID")]
    r"""The unique identifier for the library section."""

    library_section_title: Annotated[str, pydantic.Field(alias="librarySectionTitle")]
    r"""The title of the library section."""

    media_tag_prefix: Annotated[str, pydantic.Field(alias="mediaTagPrefix")]
    r"""The prefix used for media tag resource paths."""

    media_tag_version: Annotated[int, pydantic.Field(alias="mediaTagVersion")]
    r"""The version number for media tags."""

    metadata: Annotated[
        List[GetMediaMetaDataMetadata], pydantic.Field(alias="Metadata")
    ]
    r"""An array of metadata items."""

    library_section_uuid: Annotated[
        Optional[str], pydantic.Field(alias="librarySectionUUID")
    ] = None
    r"""The universally unique identifier for the library section."""


class GetMediaMetaDataResponseBodyTypedDict(TypedDict):
    r"""The metadata of the library item."""

    media_container: NotRequired[GetMediaMetaDataMediaContainerTypedDict]


class GetMediaMetaDataResponseBody(BaseModel):
    r"""The metadata of the library item."""

    media_container: Annotated[
        Optional[GetMediaMetaDataMediaContainer], pydantic.Field(alias="MediaContainer")
    ] = None


class GetMediaMetaDataResponseTypedDict(TypedDict):
    content_type: str
    r"""HTTP response content type for this operation"""
    status_code: int
    r"""HTTP response status code for this operation"""
    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""
    object: NotRequired[GetMediaMetaDataResponseBodyTypedDict]
    r"""The metadata of the library item."""


class GetMediaMetaDataResponse(BaseModel):
    content_type: str
    r"""HTTP response content type for this operation"""

    status_code: int
    r"""HTTP response status code for this operation"""

    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""

    object: Optional[GetMediaMetaDataResponseBody] = None
    r"""The metadata of the library item."""
