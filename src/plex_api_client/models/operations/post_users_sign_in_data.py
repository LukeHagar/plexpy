"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from enum import Enum
import httpx
from plex_api_client import utils
from plex_api_client.models import operations
from plex_api_client.models.components import (
    accepts as components_accepts,
    userprofile as components_userprofile,
)
from plex_api_client.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from plex_api_client.utils import (
    FieldMetadata,
    HeaderMetadata,
    RequestMetadata,
    validate_open_enum,
)
import pydantic
from pydantic import field_serializer, model_serializer
from pydantic.functional_validators import PlainValidator
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


POST_USERS_SIGN_IN_DATA_SERVERS = [
    "https://plex.tv/api/v2",
]


class PostUsersSignInDataGlobalsTypedDict(TypedDict):
    accepts: NotRequired[components_accepts.Accepts]
    r"""Indicates the client accepts the indicated media types"""
    client_identifier: NotRequired[str]
    r"""An opaque identifier unique to the client"""
    product: NotRequired[str]
    r"""The name of the client product"""
    version: NotRequired[str]
    r"""The version of the client application"""
    platform: NotRequired[str]
    r"""The platform of the client"""
    platform_version: NotRequired[str]
    r"""The version of the platform"""
    device: NotRequired[str]
    r"""A relatively friendly name for the client device"""
    model: NotRequired[str]
    r"""A potentially less friendly identifier for the device model"""
    device_vendor: NotRequired[str]
    r"""The device vendor"""
    device_name: NotRequired[str]
    r"""A friendly name for the client"""
    marketplace: NotRequired[str]
    r"""The marketplace on which the client application is distributed"""


class PostUsersSignInDataGlobals(BaseModel):
    accepts: Annotated[
        Optional[components_accepts.Accepts],
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = components_accepts.Accepts.APPLICATION_XML
    r"""Indicates the client accepts the indicated media types"""

    client_identifier: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Client-Identifier"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""An opaque identifier unique to the client"""

    product: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Product"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The name of the client product"""

    version: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The version of the client application"""

    platform: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Platform"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The platform of the client"""

    platform_version: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Platform-Version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The version of the platform"""

    device: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A relatively friendly name for the client device"""

    model: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Model"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A potentially less friendly identifier for the device model"""

    device_vendor: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device-Vendor"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The device vendor"""

    device_name: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device-Name"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A friendly name for the client"""

    marketplace: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Marketplace"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The marketplace on which the client application is distributed"""


class PostUsersSignInDataRequestBodyTypedDict(TypedDict):
    r"""Login credentials"""

    login: str
    password: str
    remember_me: NotRequired[bool]
    verification_code: NotRequired[str]


class PostUsersSignInDataRequestBody(BaseModel):
    r"""Login credentials"""

    login: Annotated[str, FieldMetadata(form=True)]

    password: Annotated[str, FieldMetadata(form=True)]

    remember_me: Annotated[
        Optional[bool], pydantic.Field(alias="rememberMe"), FieldMetadata(form=True)
    ] = False

    verification_code: Annotated[
        Optional[str],
        pydantic.Field(alias="verificationCode"),
        FieldMetadata(form=True),
    ] = None


class PostUsersSignInDataRequestTypedDict(TypedDict):
    accepts: NotRequired[components_accepts.Accepts]
    r"""Indicates the client accepts the indicated media types"""
    client_identifier: NotRequired[str]
    r"""An opaque identifier unique to the client"""
    product: NotRequired[str]
    r"""The name of the client product"""
    version: NotRequired[str]
    r"""The version of the client application"""
    platform: NotRequired[str]
    r"""The platform of the client"""
    platform_version: NotRequired[str]
    r"""The version of the platform"""
    device: NotRequired[str]
    r"""A relatively friendly name for the client device"""
    model: NotRequired[str]
    r"""A potentially less friendly identifier for the device model"""
    device_vendor: NotRequired[str]
    r"""The device vendor"""
    device_name: NotRequired[str]
    r"""A friendly name for the client"""
    marketplace: NotRequired[str]
    r"""The marketplace on which the client application is distributed"""
    request_body: NotRequired[PostUsersSignInDataRequestBodyTypedDict]
    r"""Login credentials"""


class PostUsersSignInDataRequest(BaseModel):
    accepts: Annotated[
        Optional[components_accepts.Accepts],
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = components_accepts.Accepts.APPLICATION_XML
    r"""Indicates the client accepts the indicated media types"""

    client_identifier: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Client-Identifier"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""An opaque identifier unique to the client"""

    product: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Product"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The name of the client product"""

    version: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The version of the client application"""

    platform: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Platform"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The platform of the client"""

    platform_version: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Platform-Version"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The version of the platform"""

    device: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A relatively friendly name for the client device"""

    model: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Model"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A potentially less friendly identifier for the device model"""

    device_vendor: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device-Vendor"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The device vendor"""

    device_name: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Device-Name"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""A friendly name for the client"""

    marketplace: Annotated[
        Optional[str],
        pydantic.Field(alias="X-Plex-Marketplace"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The marketplace on which the client application is distributed"""

    request_body: Annotated[
        Optional[PostUsersSignInDataRequestBody],
        FieldMetadata(
            request=RequestMetadata(media_type="application/x-www-form-urlencoded")
        ),
    ] = None
    r"""Login credentials"""


class MailingListStatus(str, Enum):
    r"""Your current mailing list status"""

    ACTIVE = "active"
    UNSUBSCRIBED = "unsubscribed"
    REMOVED = "removed"


class Status(str, Enum, metaclass=utils.OpenEnumMeta):
    ONLINE = "online"
    OFFLINE = "offline"


class ServicesTypedDict(TypedDict):
    identifier: str
    endpoint: str
    token: Nullable[str]
    secret: Nullable[str]
    status: Status


class Services(BaseModel):
    identifier: str

    endpoint: str

    token: Nullable[str]

    secret: Nullable[str]

    status: Annotated[Status, PlainValidator(validate_open_enum(False))]

    @field_serializer("status")
    def serialize_status(self, value):
        if isinstance(value, str):
            try:
                return operations.Status(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["token", "secret"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PostUsersSignInDataStatus(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""String representation of subscriptionActive"""

    INACTIVE = "Inactive"
    ACTIVE = "Active"


class SubscriptionTypedDict(TypedDict):
    r"""If the account's Plex Pass subscription is active"""

    features: NotRequired[List[str]]
    r"""List of features allowed on your Plex Pass subscription"""
    active: NotRequired[bool]
    r"""If the account's Plex Pass subscription is active"""
    subscribed_at: NotRequired[Nullable[str]]
    r"""Date the account subscribed to Plex Pass"""
    status: NotRequired[PostUsersSignInDataStatus]
    r"""String representation of subscriptionActive"""
    payment_service: NotRequired[Nullable[str]]
    r"""Payment service used for your Plex Pass subscription"""
    plan: NotRequired[Nullable[str]]
    r"""Name of Plex Pass subscription plan"""


class Subscription(BaseModel):
    r"""If the account's Plex Pass subscription is active"""

    features: Optional[List[str]] = None
    r"""List of features allowed on your Plex Pass subscription"""

    active: Optional[bool] = None
    r"""If the account's Plex Pass subscription is active"""

    subscribed_at: Annotated[
        OptionalNullable[str], pydantic.Field(alias="subscribedAt")
    ] = UNSET
    r"""Date the account subscribed to Plex Pass"""

    status: Annotated[
        Optional[PostUsersSignInDataStatus], PlainValidator(validate_open_enum(False))
    ] = None
    r"""String representation of subscriptionActive"""

    payment_service: Annotated[
        OptionalNullable[str], pydantic.Field(alias="paymentService")
    ] = UNSET
    r"""Payment service used for your Plex Pass subscription"""

    plan: OptionalNullable[str] = UNSET
    r"""Name of Plex Pass subscription plan"""

    @field_serializer("status")
    def serialize_status(self, value):
        if isinstance(value, str):
            try:
                return operations.PostUsersSignInDataStatus(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "features",
            "active",
            "subscribedAt",
            "status",
            "paymentService",
            "plan",
        ]
        nullable_fields = ["subscribedAt", "paymentService", "plan"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PostUsersSignInDataAuthenticationStatus(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""String representation of subscriptionActive"""

    INACTIVE = "Inactive"
    ACTIVE = "Active"


class PostUsersSignInDataSubscriptionTypedDict(TypedDict):
    features: NotRequired[List[str]]
    r"""List of features allowed on your Plex Pass subscription"""
    active: NotRequired[bool]
    r"""If the account's Plex Pass subscription is active"""
    subscribed_at: NotRequired[Nullable[str]]
    r"""Date the account subscribed to Plex Pass"""
    status: NotRequired[PostUsersSignInDataAuthenticationStatus]
    r"""String representation of subscriptionActive"""
    payment_service: NotRequired[Nullable[str]]
    r"""Payment service used for your Plex Pass subscription"""
    plan: NotRequired[Nullable[str]]
    r"""Name of Plex Pass subscription plan"""


class PostUsersSignInDataSubscription(BaseModel):
    features: Optional[List[str]] = None
    r"""List of features allowed on your Plex Pass subscription"""

    active: Optional[bool] = None
    r"""If the account's Plex Pass subscription is active"""

    subscribed_at: Annotated[
        OptionalNullable[str], pydantic.Field(alias="subscribedAt")
    ] = UNSET
    r"""Date the account subscribed to Plex Pass"""

    status: Annotated[
        Optional[PostUsersSignInDataAuthenticationStatus],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""String representation of subscriptionActive"""

    payment_service: Annotated[
        OptionalNullable[str], pydantic.Field(alias="paymentService")
    ] = UNSET
    r"""Payment service used for your Plex Pass subscription"""

    plan: OptionalNullable[str] = UNSET
    r"""Name of Plex Pass subscription plan"""

    @field_serializer("status")
    def serialize_status(self, value):
        if isinstance(value, str):
            try:
                return operations.PostUsersSignInDataAuthenticationStatus(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "features",
            "active",
            "subscribedAt",
            "status",
            "paymentService",
            "plan",
        ]
        nullable_fields = ["subscribedAt", "paymentService", "plan"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PostUsersSignInDataState(str, Enum, metaclass=utils.OpenEnumMeta):
    ENDED = "ended"


class InternalPaymentMethodTypedDict(TypedDict):
    pass


class InternalPaymentMethod(BaseModel):
    pass


class BillingTypedDict(TypedDict):
    internal_payment_method: InternalPaymentMethodTypedDict
    payment_method_id: Nullable[int]


class Billing(BaseModel):
    internal_payment_method: Annotated[
        InternalPaymentMethod, pydantic.Field(alias="internalPaymentMethod")
    ]

    payment_method_id: Annotated[Nullable[int], pydantic.Field(alias="paymentMethodId")]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["paymentMethodId"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PastSubscriptionTypedDict(TypedDict):
    id: Nullable[str]
    mode: Nullable[str]
    renews_at: Nullable[int]
    ends_at: Nullable[int]
    type: str
    transfer: Nullable[str]
    state: PostUsersSignInDataState
    billing: BillingTypedDict
    canceled: NotRequired[bool]
    grace_period: NotRequired[bool]
    on_hold: NotRequired[bool]
    can_reactivate: NotRequired[bool]
    can_upgrade: NotRequired[bool]
    can_downgrade: NotRequired[bool]
    can_convert: NotRequired[bool]


class PastSubscription(BaseModel):
    id: Nullable[str]

    mode: Nullable[str]

    renews_at: Annotated[Nullable[int], pydantic.Field(alias="renewsAt")]

    ends_at: Annotated[Nullable[int], pydantic.Field(alias="endsAt")]

    type: str

    transfer: Nullable[str]

    state: Annotated[
        PostUsersSignInDataState, PlainValidator(validate_open_enum(False))
    ]

    billing: Billing

    canceled: Optional[bool] = False

    grace_period: Annotated[Optional[bool], pydantic.Field(alias="gracePeriod")] = False

    on_hold: Annotated[Optional[bool], pydantic.Field(alias="onHold")] = False

    can_reactivate: Annotated[Optional[bool], pydantic.Field(alias="canReactivate")] = (
        False
    )

    can_upgrade: Annotated[Optional[bool], pydantic.Field(alias="canUpgrade")] = False

    can_downgrade: Annotated[Optional[bool], pydantic.Field(alias="canDowngrade")] = (
        False
    )

    can_convert: Annotated[Optional[bool], pydantic.Field(alias="canConvert")] = False

    @field_serializer("state")
    def serialize_state(self, value):
        if isinstance(value, str):
            try:
                return operations.PostUsersSignInDataState(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "canceled",
            "gracePeriod",
            "onHold",
            "canReactivate",
            "canUpgrade",
            "canDowngrade",
            "canConvert",
        ]
        nullable_fields = ["id", "mode", "renewsAt", "endsAt", "transfer"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class TrialsTypedDict(TypedDict):
    pass


class Trials(BaseModel):
    pass


class PostUsersSignInDataUserPlexAccountTypedDict(TypedDict):
    r"""Returns the user account data with a valid auth token"""

    auth_token: str
    r"""The account token"""
    email: str
    r"""The account email address"""
    friendly_name: str
    r"""Your account full name"""
    id: int
    r"""The Plex account ID"""
    joined_at: int
    r"""Unix epoch datetime in seconds"""
    title: str
    r"""The title of the account (username or friendly name)"""
    username: str
    r"""The account username"""
    uuid: str
    r"""The account UUID"""
    past_subscriptions: List[PastSubscriptionTypedDict]
    trials: List[TrialsTypedDict]
    ads_consent: NotRequired[Nullable[bool]]
    r"""Unknown"""
    ads_consent_reminder_at: NotRequired[Nullable[int]]
    ads_consent_set_at: NotRequired[Nullable[int]]
    anonymous: NotRequired[Nullable[bool]]
    r"""Unknown"""
    backup_codes_created: NotRequired[bool]
    r"""If the two-factor authentication backup codes have been created"""
    confirmed: NotRequired[bool]
    r"""If the account has been confirmed"""
    country: NotRequired[str]
    r"""The account country"""
    email_only_auth: NotRequired[bool]
    r"""If login with email only is enabled"""
    experimental_features: NotRequired[bool]
    r"""If experimental features are enabled"""
    entitlements: NotRequired[List[str]]
    r"""List of devices your allowed to use with this account"""
    guest: NotRequired[bool]
    r"""If the account is a Plex Home guest user"""
    has_password: NotRequired[bool]
    r"""If the account has a password"""
    home: NotRequired[bool]
    r"""If the account is a Plex Home user"""
    home_admin: NotRequired[bool]
    r"""If the account is the Plex Home admin"""
    home_size: NotRequired[int]
    r"""The number of accounts in the Plex Home"""
    locale: NotRequired[Nullable[str]]
    r"""The account locale"""
    mailing_list_active: NotRequired[bool]
    r"""If you are subscribed to the Plex newsletter"""
    mailing_list_status: NotRequired[MailingListStatus]
    r"""Your current mailing list status"""
    max_home_size: NotRequired[int]
    r"""The maximum number of accounts allowed in the Plex Home"""
    pin: NotRequired[str]
    r"""[Might be removed] The hashed Plex Home PIN"""
    profile: NotRequired[components_userprofile.UserProfileTypedDict]
    protected: NotRequired[bool]
    r"""If the account has a Plex Home PIN enabled"""
    remember_expires_at: NotRequired[int]
    r"""Unix epoch datetime in seconds"""
    restricted: NotRequired[bool]
    r"""If the account is a Plex Home managed user"""
    roles: NotRequired[List[str]]
    r"""[Might be removed] List of account roles. Plexpass membership listed here"""
    scrobble_types: NotRequired[str]
    r"""Unknown"""
    services: NotRequired[List[ServicesTypedDict]]
    subscription: NotRequired[SubscriptionTypedDict]
    r"""If the account's Plex Pass subscription is active"""
    subscription_description: NotRequired[Nullable[str]]
    r"""Description of the Plex Pass subscription"""
    subscriptions: NotRequired[List[PostUsersSignInDataSubscriptionTypedDict]]
    thumb: NotRequired[str]
    r"""URL of the account thumbnail"""
    two_factor_enabled: NotRequired[bool]
    r"""If two-factor authentication is enabled"""
    attribution_partner: NotRequired[Nullable[str]]


class PostUsersSignInDataUserPlexAccount(BaseModel):
    r"""Returns the user account data with a valid auth token"""

    auth_token: Annotated[str, pydantic.Field(alias="authToken")]
    r"""The account token"""

    email: str
    r"""The account email address"""

    friendly_name: Annotated[str, pydantic.Field(alias="friendlyName")]
    r"""Your account full name"""

    id: int
    r"""The Plex account ID"""

    joined_at: Annotated[int, pydantic.Field(alias="joinedAt")]
    r"""Unix epoch datetime in seconds"""

    title: str
    r"""The title of the account (username or friendly name)"""

    username: str
    r"""The account username"""

    uuid: str
    r"""The account UUID"""

    past_subscriptions: Annotated[
        List[PastSubscription], pydantic.Field(alias="pastSubscriptions")
    ]

    trials: List[Trials]

    ads_consent: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="adsConsent")
    ] = UNSET
    r"""Unknown"""

    ads_consent_reminder_at: Annotated[
        OptionalNullable[int], pydantic.Field(alias="adsConsentReminderAt")
    ] = UNSET

    ads_consent_set_at: Annotated[
        OptionalNullable[int], pydantic.Field(alias="adsConsentSetAt")
    ] = UNSET

    anonymous: OptionalNullable[bool] = False
    r"""Unknown"""

    backup_codes_created: Annotated[
        Optional[bool], pydantic.Field(alias="backupCodesCreated")
    ] = False
    r"""If the two-factor authentication backup codes have been created"""

    confirmed: Optional[bool] = False
    r"""If the account has been confirmed"""

    country: Optional[str] = None
    r"""The account country"""

    email_only_auth: Annotated[
        Optional[bool], pydantic.Field(alias="emailOnlyAuth")
    ] = False
    r"""If login with email only is enabled"""

    experimental_features: Annotated[
        Optional[bool], pydantic.Field(alias="experimentalFeatures")
    ] = False
    r"""If experimental features are enabled"""

    entitlements: Optional[List[str]] = None
    r"""List of devices your allowed to use with this account"""

    guest: Optional[bool] = False
    r"""If the account is a Plex Home guest user"""

    has_password: Annotated[Optional[bool], pydantic.Field(alias="hasPassword")] = True
    r"""If the account has a password"""

    home: Optional[bool] = False
    r"""If the account is a Plex Home user"""

    home_admin: Annotated[Optional[bool], pydantic.Field(alias="homeAdmin")] = False
    r"""If the account is the Plex Home admin"""

    home_size: Annotated[Optional[int], pydantic.Field(alias="homeSize")] = None
    r"""The number of accounts in the Plex Home"""

    locale: OptionalNullable[str] = UNSET
    r"""The account locale"""

    mailing_list_active: Annotated[
        Optional[bool], pydantic.Field(alias="mailingListActive")
    ] = False
    r"""If you are subscribed to the Plex newsletter"""

    mailing_list_status: Annotated[
        Optional[MailingListStatus], pydantic.Field(alias="mailingListStatus")
    ] = None
    r"""Your current mailing list status"""

    max_home_size: Annotated[Optional[int], pydantic.Field(alias="maxHomeSize")] = None
    r"""The maximum number of accounts allowed in the Plex Home"""

    pin: Annotated[
        Optional[str],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
        ),
    ] = None
    r"""[Might be removed] The hashed Plex Home PIN"""

    profile: Optional[components_userprofile.UserProfile] = None

    protected: Optional[bool] = False
    r"""If the account has a Plex Home PIN enabled"""

    remember_expires_at: Annotated[
        Optional[int], pydantic.Field(alias="rememberExpiresAt")
    ] = None
    r"""Unix epoch datetime in seconds"""

    restricted: Optional[bool] = False
    r"""If the account is a Plex Home managed user"""

    roles: Optional[List[str]] = None
    r"""[Might be removed] List of account roles. Plexpass membership listed here"""

    scrobble_types: Annotated[Optional[str], pydantic.Field(alias="scrobbleTypes")] = (
        None
    )
    r"""Unknown"""

    services: Optional[List[Services]] = None

    subscription: Optional[Subscription] = None
    r"""If the account's Plex Pass subscription is active"""

    subscription_description: Annotated[
        OptionalNullable[str], pydantic.Field(alias="subscriptionDescription")
    ] = UNSET
    r"""Description of the Plex Pass subscription"""

    subscriptions: Optional[List[PostUsersSignInDataSubscription]] = None

    thumb: Optional[str] = None
    r"""URL of the account thumbnail"""

    two_factor_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="twoFactorEnabled")
    ] = False
    r"""If two-factor authentication is enabled"""

    attribution_partner: Annotated[
        OptionalNullable[str], pydantic.Field(alias="attributionPartner")
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "adsConsent",
            "adsConsentReminderAt",
            "adsConsentSetAt",
            "anonymous",
            "backupCodesCreated",
            "confirmed",
            "country",
            "emailOnlyAuth",
            "experimentalFeatures",
            "entitlements",
            "guest",
            "hasPassword",
            "home",
            "homeAdmin",
            "homeSize",
            "locale",
            "mailingListActive",
            "mailingListStatus",
            "maxHomeSize",
            "pin",
            "profile",
            "protected",
            "rememberExpiresAt",
            "restricted",
            "roles",
            "scrobbleTypes",
            "services",
            "subscription",
            "subscriptionDescription",
            "subscriptions",
            "thumb",
            "twoFactorEnabled",
            "attributionPartner",
        ]
        nullable_fields = [
            "adsConsent",
            "adsConsentReminderAt",
            "adsConsentSetAt",
            "anonymous",
            "locale",
            "subscriptionDescription",
            "attributionPartner",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class PostUsersSignInDataResponseTypedDict(TypedDict):
    content_type: str
    r"""HTTP response content type for this operation"""
    status_code: int
    r"""HTTP response status code for this operation"""
    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""
    user_plex_account: NotRequired[PostUsersSignInDataUserPlexAccountTypedDict]
    r"""Returns the user account data with a valid auth token"""


class PostUsersSignInDataResponse(BaseModel):
    content_type: str
    r"""HTTP response content type for this operation"""

    status_code: int
    r"""HTTP response status code for this operation"""

    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""

    user_plex_account: Optional[PostUsersSignInDataUserPlexAccount] = None
    r"""Returns the user account data with a valid auth token"""
