"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import datetime
from enum import Enum
import httpx
from plex_api_client import utils
from plex_api_client.types import BaseModel
from plex_api_client.utils import FieldMetadata, QueryParamMetadata, validate_open_enum
import pydantic
from pydantic.functional_validators import PlainValidator
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class QueryParamType(int, Enum, metaclass=utils.OpenEnumMeta):
    r"""The type of media to retrieve or filter by.
    1 = movie
    2 = show
    3 = season
    4 = episode
    E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries

    """

    MOVIE = 1
    TV_SHOW = 2
    SEASON = 3
    EPISODE = 4
    AUDIO = 8
    ALBUM = 9
    TRACK = 10


class QueryParamIncludeMeta(int, Enum):
    r"""Adds the Meta object to the response"""

    DISABLE = 0
    ENABLE = 1


class GetRecentlyAddedLibraryRequestTypedDict(TypedDict):
    type: QueryParamType
    r"""The type of media to retrieve or filter by.
    1 = movie
    2 = show
    3 = season
    4 = episode
    E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries

    """
    content_directory_id: NotRequired[int]
    pinned_content_directory_id: NotRequired[List[int]]
    section_id: NotRequired[int]
    r"""The library section ID for filtering content."""
    include_meta: NotRequired[QueryParamIncludeMeta]
    r"""Adds the Meta object to the response

    """
    x_plex_container_start: NotRequired[int]
    r"""The index of the first item to return. If not specified, the first item will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 0

    """
    x_plex_container_size: NotRequired[int]
    r"""The number of items to return. If not specified, all items will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 50

    """


class GetRecentlyAddedLibraryRequest(BaseModel):
    type: Annotated[
        Annotated[QueryParamType, PlainValidator(validate_open_enum(True))],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ]
    r"""The type of media to retrieve or filter by.
    1 = movie
    2 = show
    3 = season
    4 = episode
    E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries

    """

    content_directory_id: Annotated[
        Optional[int],
        pydantic.Field(alias="contentDirectoryID"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None

    pinned_content_directory_id: Annotated[
        Optional[List[int]],
        pydantic.Field(alias="pinnedContentDirectoryID"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None

    section_id: Annotated[
        Optional[int],
        pydantic.Field(alias="sectionID"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""The library section ID for filtering content."""

    include_meta: Annotated[
        Optional[QueryParamIncludeMeta],
        pydantic.Field(alias="includeMeta"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = QueryParamIncludeMeta.DISABLE
    r"""Adds the Meta object to the response

    """

    x_plex_container_start: Annotated[
        Optional[int],
        pydantic.Field(alias="X-Plex-Container-Start"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 0
    r"""The index of the first item to return. If not specified, the first item will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 0

    """

    x_plex_container_size: Annotated[
        Optional[int],
        pydantic.Field(alias="X-Plex-Container-Size"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 50
    r"""The number of items to return. If not specified, all items will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 50

    """


class GetRecentlyAddedLibraryFilterTypedDict(TypedDict):
    filter_: str
    filter_type: str
    key: str
    title: str
    type: str
    advanced: NotRequired[bool]


class GetRecentlyAddedLibraryFilter(BaseModel):
    filter_: Annotated[str, pydantic.Field(alias="filter")]

    filter_type: Annotated[str, pydantic.Field(alias="filterType")]

    key: str

    title: str

    type: str

    advanced: Optional[bool] = None


class ActiveDirection(str, Enum):
    r"""The direction of the sort. Can be either `asc` or `desc`."""

    ASCENDING = "asc"
    DESCENDING = "desc"


class DefaultDirection(str, Enum):
    r"""The direction of the sort. Can be either `asc` or `desc`."""

    ASCENDING = "asc"
    DESCENDING = "desc"


class SortTypedDict(TypedDict):
    key: str
    title: str
    default: NotRequired[str]
    active: NotRequired[bool]
    active_direction: NotRequired[ActiveDirection]
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """
    default_direction: NotRequired[DefaultDirection]
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """
    desc_key: NotRequired[str]
    first_character_key: NotRequired[str]


class Sort(BaseModel):
    key: str

    title: str

    default: Optional[str] = None

    active: Optional[bool] = None

    active_direction: Annotated[
        Optional[ActiveDirection], pydantic.Field(alias="activeDirection")
    ] = ActiveDirection.ASCENDING
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """

    default_direction: Annotated[
        Optional[DefaultDirection], pydantic.Field(alias="defaultDirection")
    ] = DefaultDirection.ASCENDING
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """

    desc_key: Annotated[Optional[str], pydantic.Field(alias="descKey")] = None

    first_character_key: Annotated[
        Optional[str], pydantic.Field(alias="firstCharacterKey")
    ] = None


class FieldTTypedDict(TypedDict):
    key: str
    title: str
    type: str
    sub_type: NotRequired[str]


class FieldT(BaseModel):
    key: str

    title: str

    type: str

    sub_type: Annotated[Optional[str], pydantic.Field(alias="subType")] = None


class GetRecentlyAddedLibraryTypeTypedDict(TypedDict):
    key: str
    type: str
    title: str
    active: bool
    subtype: NotRequired[str]
    filter_: NotRequired[List[GetRecentlyAddedLibraryFilterTypedDict]]
    sort: NotRequired[List[SortTypedDict]]
    field: NotRequired[List[FieldTTypedDict]]


class GetRecentlyAddedLibraryType(BaseModel):
    key: str

    type: str

    title: str

    active: bool

    subtype: Optional[str] = None

    filter_: Annotated[
        Optional[List[GetRecentlyAddedLibraryFilter]], pydantic.Field(alias="Filter")
    ] = None

    sort: Annotated[Optional[List[Sort]], pydantic.Field(alias="Sort")] = None

    field: Annotated[Optional[List[FieldT]], pydantic.Field(alias="Field")] = None


class OperatorTypedDict(TypedDict):
    key: str
    title: str


class Operator(BaseModel):
    key: str

    title: str


class FieldTypeTypedDict(TypedDict):
    type: str
    operator: List[OperatorTypedDict]


class FieldType(BaseModel):
    type: str

    operator: Annotated[List[Operator], pydantic.Field(alias="Operator")]


class GetRecentlyAddedLibraryPartTypedDict(TypedDict):
    id: NotRequired[float]
    key: NotRequired[str]
    duration: NotRequired[float]
    file: NotRequired[str]
    size: NotRequired[float]
    container: NotRequired[str]
    has64bit_offsets: NotRequired[bool]
    has_thumbnail: NotRequired[float]
    optimized_for_streaming: NotRequired[bool]
    video_profile: NotRequired[str]


class GetRecentlyAddedLibraryPart(BaseModel):
    id: Optional[float] = None

    key: Optional[str] = None

    duration: Optional[float] = None

    file: Optional[str] = None

    size: Optional[float] = None

    container: Optional[str] = None

    has64bit_offsets: Annotated[
        Optional[bool], pydantic.Field(alias="has64bitOffsets")
    ] = None

    has_thumbnail: Annotated[Optional[float], pydantic.Field(alias="hasThumbnail")] = (
        None
    )

    optimized_for_streaming: Annotated[
        Optional[bool], pydantic.Field(alias="optimizedForStreaming")
    ] = None

    video_profile: Annotated[Optional[str], pydantic.Field(alias="videoProfile")] = None


class GetRecentlyAddedLibraryMediaTypedDict(TypedDict):
    id: NotRequired[float]
    duration: NotRequired[float]
    bitrate: NotRequired[float]
    width: NotRequired[float]
    height: NotRequired[float]
    aspect_ratio: NotRequired[float]
    audio_channels: NotRequired[float]
    audio_codec: NotRequired[str]
    video_codec: NotRequired[str]
    video_resolution: NotRequired[float]
    container: NotRequired[str]
    video_frame_rate: NotRequired[str]
    optimized_for_streaming: NotRequired[float]
    has64bit_offsets: NotRequired[bool]
    video_profile: NotRequired[str]
    part: NotRequired[List[GetRecentlyAddedLibraryPartTypedDict]]


class GetRecentlyAddedLibraryMedia(BaseModel):
    id: Optional[float] = None

    duration: Optional[float] = None

    bitrate: Optional[float] = None

    width: Optional[float] = None

    height: Optional[float] = None

    aspect_ratio: Annotated[Optional[float], pydantic.Field(alias="aspectRatio")] = None

    audio_channels: Annotated[
        Optional[float], pydantic.Field(alias="audioChannels")
    ] = None

    audio_codec: Annotated[Optional[str], pydantic.Field(alias="audioCodec")] = None

    video_codec: Annotated[Optional[str], pydantic.Field(alias="videoCodec")] = None

    video_resolution: Annotated[
        Optional[float], pydantic.Field(alias="videoResolution")
    ] = None

    container: Optional[str] = None

    video_frame_rate: Annotated[
        Optional[str], pydantic.Field(alias="videoFrameRate")
    ] = None

    optimized_for_streaming: Annotated[
        Optional[float], pydantic.Field(alias="optimizedForStreaming")
    ] = None

    has64bit_offsets: Annotated[
        Optional[bool], pydantic.Field(alias="has64bitOffsets")
    ] = None

    video_profile: Annotated[Optional[str], pydantic.Field(alias="videoProfile")] = None

    part: Annotated[
        Optional[List[GetRecentlyAddedLibraryPart]], pydantic.Field(alias="Part")
    ] = None


class GetRecentlyAddedLibraryGenreTypedDict(TypedDict):
    tag: NotRequired[str]


class GetRecentlyAddedLibraryGenre(BaseModel):
    tag: Optional[str] = None


class GetRecentlyAddedLibraryDirectorTypedDict(TypedDict):
    tag: NotRequired[str]


class GetRecentlyAddedLibraryDirector(BaseModel):
    tag: Optional[str] = None


class GetRecentlyAddedLibraryWriterTypedDict(TypedDict):
    tag: NotRequired[str]


class GetRecentlyAddedLibraryWriter(BaseModel):
    tag: Optional[str] = None


class GetRecentlyAddedLibraryCountryTypedDict(TypedDict):
    tag: NotRequired[str]


class GetRecentlyAddedLibraryCountry(BaseModel):
    tag: Optional[str] = None


class GetRecentlyAddedLibraryRoleTypedDict(TypedDict):
    tag: NotRequired[str]


class GetRecentlyAddedLibraryRole(BaseModel):
    tag: Optional[str] = None


class GetRecentlyAddedLibraryMetadataTypedDict(TypedDict):
    allow_sync: NotRequired[bool]
    library_section_id: NotRequired[float]
    library_section_title: NotRequired[str]
    library_section_uuid: NotRequired[str]
    rating_key: NotRequired[float]
    key: NotRequired[str]
    guid: NotRequired[str]
    studio: NotRequired[str]
    type: NotRequired[str]
    title: NotRequired[str]
    content_rating: NotRequired[str]
    summary: NotRequired[str]
    rating: NotRequired[float]
    audience_rating: NotRequired[float]
    year: NotRequired[float]
    tagline: NotRequired[str]
    thumb: NotRequired[str]
    art: NotRequired[str]
    duration: NotRequired[float]
    originally_available_at: NotRequired[datetime]
    added_at: NotRequired[float]
    updated_at: NotRequired[float]
    audience_rating_image: NotRequired[str]
    chapter_source: NotRequired[str]
    primary_extra_key: NotRequired[str]
    rating_image: NotRequired[str]
    media: NotRequired[List[GetRecentlyAddedLibraryMediaTypedDict]]
    genre: NotRequired[List[GetRecentlyAddedLibraryGenreTypedDict]]
    director: NotRequired[List[GetRecentlyAddedLibraryDirectorTypedDict]]
    writer: NotRequired[List[GetRecentlyAddedLibraryWriterTypedDict]]
    country: NotRequired[List[GetRecentlyAddedLibraryCountryTypedDict]]
    role: NotRequired[List[GetRecentlyAddedLibraryRoleTypedDict]]


class GetRecentlyAddedLibraryMetadata(BaseModel):
    allow_sync: Annotated[Optional[bool], pydantic.Field(alias="allowSync")] = None

    library_section_id: Annotated[
        Optional[float], pydantic.Field(alias="librarySectionID")
    ] = None

    library_section_title: Annotated[
        Optional[str], pydantic.Field(alias="librarySectionTitle")
    ] = None

    library_section_uuid: Annotated[
        Optional[str], pydantic.Field(alias="librarySectionUUID")
    ] = None

    rating_key: Annotated[Optional[float], pydantic.Field(alias="ratingKey")] = None

    key: Optional[str] = None

    guid: Optional[str] = None

    studio: Optional[str] = None

    type: Optional[str] = None

    title: Optional[str] = None

    content_rating: Annotated[Optional[str], pydantic.Field(alias="contentRating")] = (
        None
    )

    summary: Optional[str] = None

    rating: Optional[float] = None

    audience_rating: Annotated[
        Optional[float], pydantic.Field(alias="audienceRating")
    ] = None

    year: Optional[float] = None

    tagline: Optional[str] = None

    thumb: Optional[str] = None

    art: Optional[str] = None

    duration: Optional[float] = None

    originally_available_at: Annotated[
        Optional[datetime], pydantic.Field(alias="originallyAvailableAt")
    ] = None

    added_at: Annotated[Optional[float], pydantic.Field(alias="addedAt")] = None

    updated_at: Annotated[Optional[float], pydantic.Field(alias="updatedAt")] = None

    audience_rating_image: Annotated[
        Optional[str], pydantic.Field(alias="audienceRatingImage")
    ] = None

    chapter_source: Annotated[Optional[str], pydantic.Field(alias="chapterSource")] = (
        None
    )

    primary_extra_key: Annotated[
        Optional[str], pydantic.Field(alias="primaryExtraKey")
    ] = None

    rating_image: Annotated[Optional[str], pydantic.Field(alias="ratingImage")] = None

    media: Annotated[
        Optional[List[GetRecentlyAddedLibraryMedia]], pydantic.Field(alias="Media")
    ] = None

    genre: Annotated[
        Optional[List[GetRecentlyAddedLibraryGenre]], pydantic.Field(alias="Genre")
    ] = None

    director: Annotated[
        Optional[List[GetRecentlyAddedLibraryDirector]],
        pydantic.Field(alias="Director"),
    ] = None

    writer: Annotated[
        Optional[List[GetRecentlyAddedLibraryWriter]], pydantic.Field(alias="Writer")
    ] = None

    country: Annotated[
        Optional[List[GetRecentlyAddedLibraryCountry]], pydantic.Field(alias="Country")
    ] = None

    role: Annotated[
        Optional[List[GetRecentlyAddedLibraryRole]], pydantic.Field(alias="Role")
    ] = None


class GetRecentlyAddedLibraryMediaContainerTypedDict(TypedDict):
    r"""The Meta object is only included in the response if the `includeMeta` parameter is set to `1`."""

    type: NotRequired[List[GetRecentlyAddedLibraryTypeTypedDict]]
    field_type: NotRequired[List[FieldTypeTypedDict]]
    size: NotRequired[float]
    allow_sync: NotRequired[bool]
    identifier: NotRequired[str]
    media_tag_prefix: NotRequired[str]
    media_tag_version: NotRequired[float]
    mixed_parents: NotRequired[bool]
    metadata: NotRequired[List[GetRecentlyAddedLibraryMetadataTypedDict]]


class GetRecentlyAddedLibraryMediaContainer(BaseModel):
    r"""The Meta object is only included in the response if the `includeMeta` parameter is set to `1`."""

    type: Annotated[
        Optional[List[GetRecentlyAddedLibraryType]], pydantic.Field(alias="Type")
    ] = None

    field_type: Annotated[
        Optional[List[FieldType]], pydantic.Field(alias="FieldType")
    ] = None

    size: Optional[float] = None

    allow_sync: Annotated[Optional[bool], pydantic.Field(alias="allowSync")] = None

    identifier: Optional[str] = None

    media_tag_prefix: Annotated[
        Optional[str], pydantic.Field(alias="mediaTagPrefix")
    ] = None

    media_tag_version: Annotated[
        Optional[float], pydantic.Field(alias="mediaTagVersion")
    ] = None

    mixed_parents: Annotated[Optional[bool], pydantic.Field(alias="mixedParents")] = (
        None
    )

    metadata: Annotated[
        Optional[List[GetRecentlyAddedLibraryMetadata]],
        pydantic.Field(alias="Metadata"),
    ] = None


class GetRecentlyAddedLibraryResponseBodyTypedDict(TypedDict):
    r"""The recently added content"""

    media_container: NotRequired[GetRecentlyAddedLibraryMediaContainerTypedDict]


class GetRecentlyAddedLibraryResponseBody(BaseModel):
    r"""The recently added content"""

    media_container: Annotated[
        Optional[GetRecentlyAddedLibraryMediaContainer],
        pydantic.Field(alias="MediaContainer"),
    ] = None


class GetRecentlyAddedLibraryResponseTypedDict(TypedDict):
    content_type: str
    r"""HTTP response content type for this operation"""
    status_code: int
    r"""HTTP response status code for this operation"""
    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""
    object: NotRequired[GetRecentlyAddedLibraryResponseBodyTypedDict]
    r"""The recently added content"""


class GetRecentlyAddedLibraryResponse(BaseModel):
    content_type: str
    r"""HTTP response content type for this operation"""

    status_code: int
    r"""HTTP response status code for this operation"""

    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""

    object: Optional[GetRecentlyAddedLibraryResponseBody] = None
    r"""The recently added content"""
