"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import date
from enum import Enum
import httpx
from plex_api_client import utils
from plex_api_client.types import BaseModel
from plex_api_client.utils import (
    FieldMetadata,
    PathParamMetadata,
    QueryParamMetadata,
    validate_const,
    validate_open_enum,
)
import pydantic
from pydantic.functional_validators import AfterValidator, PlainValidator
from typing import List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class GetLibrarySectionsAllQueryParamType(int, Enum, metaclass=utils.OpenEnumMeta):
    r"""The type of media to retrieve or filter by.
    1 = movie
    2 = show
    3 = season
    4 = episode
    E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries

    """

    MOVIE = 1
    TV_SHOW = 2
    SEASON = 3
    EPISODE = 4
    ARTIST = 5
    ALBUM = 6
    TRACK = 7
    PHOTO_ALBUM = 8
    PHOTO = 9


class GetLibrarySectionsAllQueryParamIncludeMeta(int, Enum):
    r"""Adds the Meta object to the response"""

    DISABLE = 0
    ENABLE = 1


class QueryParamIncludeGuids(int, Enum):
    r"""Adds the Guid object to the response"""

    DISABLE = 0
    ENABLE = 1


class IncludeAdvanced(int, Enum):
    DISABLE = 0
    ENABLE = 1


class QueryParamIncludeCollections(int, Enum):
    DISABLE = 0
    ENABLE = 1


class QueryParamIncludeExternalMedia(int, Enum):
    DISABLE = 0
    ENABLE = 1


class GetLibrarySectionsAllRequestTypedDict(TypedDict):
    section_key: int
    r"""The unique key of the Plex library.
    Note: This is unique in the context of the Plex server.

    """
    type: GetLibrarySectionsAllQueryParamType
    r"""The type of media to retrieve or filter by.
    1 = movie
    2 = show
    3 = season
    4 = episode
    E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries

    """
    include_meta: NotRequired[GetLibrarySectionsAllQueryParamIncludeMeta]
    r"""Adds the Meta object to the response

    """
    include_guids: NotRequired[QueryParamIncludeGuids]
    r"""Adds the Guid object to the response

    """
    include_advanced: NotRequired[IncludeAdvanced]
    include_collections: NotRequired[QueryParamIncludeCollections]
    include_external_media: NotRequired[QueryParamIncludeExternalMedia]
    x_plex_container_start: NotRequired[int]
    r"""The index of the first item to return. If not specified, the first item will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 0

    """
    x_plex_container_size: NotRequired[int]
    r"""The number of items to return. If not specified, all items will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 50

    """


class GetLibrarySectionsAllRequest(BaseModel):
    section_key: Annotated[
        int,
        pydantic.Field(alias="sectionKey"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""The unique key of the Plex library.
    Note: This is unique in the context of the Plex server.

    """

    type: Annotated[
        Annotated[
            GetLibrarySectionsAllQueryParamType,
            PlainValidator(validate_open_enum(True)),
        ],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ]
    r"""The type of media to retrieve or filter by.
    1 = movie
    2 = show
    3 = season
    4 = episode
    E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries

    """

    include_meta: Annotated[
        Optional[GetLibrarySectionsAllQueryParamIncludeMeta],
        pydantic.Field(alias="includeMeta"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = GetLibrarySectionsAllQueryParamIncludeMeta.DISABLE
    r"""Adds the Meta object to the response

    """

    include_guids: Annotated[
        Optional[QueryParamIncludeGuids],
        pydantic.Field(alias="includeGuids"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = QueryParamIncludeGuids.DISABLE
    r"""Adds the Guid object to the response

    """

    include_advanced: Annotated[
        Optional[IncludeAdvanced],
        pydantic.Field(alias="includeAdvanced"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = IncludeAdvanced.DISABLE

    include_collections: Annotated[
        Optional[QueryParamIncludeCollections],
        pydantic.Field(alias="includeCollections"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = QueryParamIncludeCollections.DISABLE

    include_external_media: Annotated[
        Optional[QueryParamIncludeExternalMedia],
        pydantic.Field(alias="includeExternalMedia"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = QueryParamIncludeExternalMedia.DISABLE

    x_plex_container_start: Annotated[
        Optional[int],
        pydantic.Field(alias="X-Plex-Container-Start"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 0
    r"""The index of the first item to return. If not specified, the first item will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 0

    """

    x_plex_container_size: Annotated[
        Optional[int],
        pydantic.Field(alias="X-Plex-Container-Size"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 50
    r"""The number of items to return. If not specified, all items will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 50

    """


class GetLibrarySectionsAllFilterTypedDict(TypedDict):
    filter_: str
    filter_type: str
    key: str
    title: str
    type: str
    advanced: NotRequired[bool]


class GetLibrarySectionsAllFilter(BaseModel):
    filter_: Annotated[str, pydantic.Field(alias="filter")]

    filter_type: Annotated[str, pydantic.Field(alias="filterType")]

    key: str

    title: str

    type: str

    advanced: Optional[bool] = None


class GetLibrarySectionsAllActiveDirection(str, Enum):
    r"""The direction of the sort. Can be either `asc` or `desc`."""

    ASCENDING = "asc"
    DESCENDING = "desc"


class GetLibrarySectionsAllDefaultDirection(str, Enum):
    r"""The direction of the sort. Can be either `asc` or `desc`."""

    ASCENDING = "asc"
    DESCENDING = "desc"


class GetLibrarySectionsAllSortTypedDict(TypedDict):
    key: str
    title: str
    default: NotRequired[str]
    active: NotRequired[bool]
    active_direction: NotRequired[GetLibrarySectionsAllActiveDirection]
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """
    default_direction: NotRequired[GetLibrarySectionsAllDefaultDirection]
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """
    desc_key: NotRequired[str]
    first_character_key: NotRequired[str]


class GetLibrarySectionsAllSort(BaseModel):
    key: str

    title: str

    default: Optional[str] = None

    active: Optional[bool] = None

    active_direction: Annotated[
        Optional[GetLibrarySectionsAllActiveDirection],
        pydantic.Field(alias="activeDirection"),
    ] = GetLibrarySectionsAllActiveDirection.ASCENDING
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """

    default_direction: Annotated[
        Optional[GetLibrarySectionsAllDefaultDirection],
        pydantic.Field(alias="defaultDirection"),
    ] = GetLibrarySectionsAllDefaultDirection.ASCENDING
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """

    desc_key: Annotated[Optional[str], pydantic.Field(alias="descKey")] = None

    first_character_key: Annotated[
        Optional[str], pydantic.Field(alias="firstCharacterKey")
    ] = None


class GetLibrarySectionsAllFieldTypedDict(TypedDict):
    key: str
    title: str
    type: str
    sub_type: NotRequired[str]


class GetLibrarySectionsAllField(BaseModel):
    key: str

    title: str

    type: str

    sub_type: Annotated[Optional[str], pydantic.Field(alias="subType")] = None


class GetLibrarySectionsAllTypeTypedDict(TypedDict):
    key: str
    type: str
    title: str
    active: bool
    subtype: NotRequired[str]
    filter_: NotRequired[List[GetLibrarySectionsAllFilterTypedDict]]
    sort: NotRequired[List[GetLibrarySectionsAllSortTypedDict]]
    field: NotRequired[List[GetLibrarySectionsAllFieldTypedDict]]


class GetLibrarySectionsAllType(BaseModel):
    key: str

    type: str

    title: str

    active: bool

    subtype: Optional[str] = None

    filter_: Annotated[
        Optional[List[GetLibrarySectionsAllFilter]], pydantic.Field(alias="Filter")
    ] = None

    sort: Annotated[
        Optional[List[GetLibrarySectionsAllSort]], pydantic.Field(alias="Sort")
    ] = None

    field: Annotated[
        Optional[List[GetLibrarySectionsAllField]], pydantic.Field(alias="Field")
    ] = None


class GetLibrarySectionsAllOperatorTypedDict(TypedDict):
    key: str
    title: str


class GetLibrarySectionsAllOperator(BaseModel):
    key: str

    title: str


class GetLibrarySectionsAllFieldTypeTypedDict(TypedDict):
    type: str
    operator: List[GetLibrarySectionsAllOperatorTypedDict]


class GetLibrarySectionsAllFieldType(BaseModel):
    type: str

    operator: Annotated[
        List[GetLibrarySectionsAllOperator], pydantic.Field(alias="Operator")
    ]


class GetLibrarySectionsAllMetaTypedDict(TypedDict):
    r"""The Meta object is only included in the response if the `includeMeta` parameter is set to `1`."""

    type: NotRequired[List[GetLibrarySectionsAllTypeTypedDict]]
    field_type: NotRequired[List[GetLibrarySectionsAllFieldTypeTypedDict]]


class GetLibrarySectionsAllMeta(BaseModel):
    r"""The Meta object is only included in the response if the `includeMeta` parameter is set to `1`."""

    type: Annotated[
        Optional[List[GetLibrarySectionsAllType]], pydantic.Field(alias="Type")
    ] = None

    field_type: Annotated[
        Optional[List[GetLibrarySectionsAllFieldType]],
        pydantic.Field(alias="FieldType"),
    ] = None


class GetLibrarySectionsAllLibraryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The type of media content in the Plex library. This can represent videos, music, or photos."""

    MOVIE = "movie"
    TV_SHOW = "show"
    SEASON = "season"
    EPISODE = "episode"
    ARTIST = "artist"
    ALBUM = "album"
    TRACK = "track"
    PHOTO_ALBUM = "photoalbum"
    PHOTO = "photo"
    COLLECTION = "collection"


class GetLibrarySectionsAllLibraryResponseType(str, Enum, metaclass=utils.OpenEnumMeta):
    COVER_POSTER = "coverPoster"
    BACKGROUND = "background"
    SNAPSHOT = "snapshot"
    CLEAR_LOGO = "clearLogo"


class GetLibrarySectionsAllImageTypedDict(TypedDict):
    alt: str
    type: GetLibrarySectionsAllLibraryResponseType
    url: str


class GetLibrarySectionsAllImage(BaseModel):
    alt: str

    type: Annotated[
        GetLibrarySectionsAllLibraryResponseType,
        PlainValidator(validate_open_enum(False)),
    ]

    url: str


class GetLibrarySectionsAllUltraBlurColorsTypedDict(TypedDict):
    top_left: str
    top_right: str
    bottom_right: str
    bottom_left: str


class GetLibrarySectionsAllUltraBlurColors(BaseModel):
    top_left: Annotated[str, pydantic.Field(alias="topLeft")]

    top_right: Annotated[str, pydantic.Field(alias="topRight")]

    bottom_right: Annotated[str, pydantic.Field(alias="bottomRight")]

    bottom_left: Annotated[str, pydantic.Field(alias="bottomLeft")]


class GetLibrarySectionsAllGuidsTypedDict(TypedDict):
    id: str
    r"""The unique identifier for the Guid. Can be prefixed with imdb://, tmdb://, tvdb://

    """


class GetLibrarySectionsAllGuids(BaseModel):
    id: str
    r"""The unique identifier for the Guid. Can be prefixed with imdb://, tmdb://, tvdb://

    """


class GetLibrarySectionsAllOptimizedForStreaming1(int, Enum):
    ZERO = 0
    ONE = 1


GetLibrarySectionsAllOptimizedForStreamingTypedDict = TypeAliasType(
    "GetLibrarySectionsAllOptimizedForStreamingTypedDict",
    Union[GetLibrarySectionsAllOptimizedForStreaming1, bool],
)
r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""


GetLibrarySectionsAllOptimizedForStreaming = TypeAliasType(
    "GetLibrarySectionsAllOptimizedForStreaming",
    Union[GetLibrarySectionsAllOptimizedForStreaming1, bool],
)
r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""


class GetLibrarySectionsAllOptimizedForStreamingLibrary1(int, Enum):
    ZERO = 0
    ONE = 1


GetLibrarySectionsAllLibraryOptimizedForStreamingTypedDict = TypeAliasType(
    "GetLibrarySectionsAllLibraryOptimizedForStreamingTypedDict",
    Union[GetLibrarySectionsAllOptimizedForStreamingLibrary1, bool],
)
r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""


GetLibrarySectionsAllLibraryOptimizedForStreaming = TypeAliasType(
    "GetLibrarySectionsAllLibraryOptimizedForStreaming",
    Union[GetLibrarySectionsAllOptimizedForStreamingLibrary1, bool],
)
r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""


class GetLibrarySectionsAllHasThumbnail(str, Enum):
    r"""Indicates if the part has a thumbnail."""

    FALSE = "0"
    TRUE = "1"


class GetLibrarySectionsAllStreamTypedDict(TypedDict):
    id: int
    r"""Unique stream identifier."""
    codec: str
    r"""Codec used by the stream."""
    display_title: str
    r"""Display title for the stream."""
    extended_display_title: str
    r"""Extended display title for the stream."""
    stream_type: Literal[1]
    r"""Stream type:
    - VIDEO = 1
    - AUDIO = 2
    - SUBTITLE = 3

    """
    format_: NotRequired[str]
    r"""Format of the stream (e.g., srt)."""
    default: NotRequired[bool]
    r"""Indicates if this stream is default."""
    index: NotRequired[int]
    r"""Index of the stream."""
    bitrate: NotRequired[int]
    r"""Bitrate of the stream."""
    language: NotRequired[str]
    r"""Language of the stream."""
    language_tag: NotRequired[str]
    r"""Language tag (e.g., en)."""
    language_code: NotRequired[str]
    r"""ISO language code."""
    header_compression: NotRequired[bool]
    r"""Indicates whether header compression is enabled."""
    dovibl_compat_id: NotRequired[int]
    r"""Dolby Vision BL compatibility ID."""
    dovibl_present: NotRequired[bool]
    r"""Indicates if Dolby Vision BL is present."""
    doviel_present: NotRequired[bool]
    r"""Indicates if Dolby Vision EL is present."""
    dovi_level: NotRequired[int]
    r"""Dolby Vision level."""
    dovi_present: NotRequired[bool]
    r"""Indicates if Dolby Vision is present."""
    dovi_profile: NotRequired[int]
    r"""Dolby Vision profile."""
    dovirpu_present: NotRequired[bool]
    r"""Indicates if Dolby Vision RPU is present."""
    dovi_version: NotRequired[str]
    r"""Dolby Vision version."""
    bit_depth: NotRequired[int]
    r"""Bit depth of the video stream."""
    chroma_location: NotRequired[str]
    r"""Chroma sample location."""
    chroma_subsampling: NotRequired[str]
    r"""Chroma subsampling format."""
    coded_height: NotRequired[int]
    r"""Coded video height."""
    coded_width: NotRequired[int]
    r"""Coded video width."""
    closed_captions: NotRequired[bool]
    color_primaries: NotRequired[str]
    r"""Color primaries used."""
    color_range: NotRequired[str]
    r"""Color range (e.g., tv)."""
    color_space: NotRequired[str]
    r"""Color space."""
    color_trc: NotRequired[str]
    r"""Color transfer characteristics."""
    frame_rate: NotRequired[float]
    r"""Frame rate of the stream."""
    key: NotRequired[str]
    r"""Key to access this stream part."""
    height: NotRequired[int]
    r"""Height of the video stream."""
    level: NotRequired[int]
    r"""Video level."""
    original: NotRequired[bool]
    r"""Indicates if this is the original stream."""
    has_scaling_matrix: NotRequired[bool]
    profile: NotRequired[str]
    r"""Video profile."""
    scan_type: NotRequired[str]
    embedded_in_video: NotRequired[str]
    ref_frames: NotRequired[int]
    r"""Number of reference frames."""
    width: NotRequired[int]
    r"""Width of the video stream."""
    selected: NotRequired[bool]
    r"""Indicates if this stream is selected (applicable for audio streams)."""
    forced: NotRequired[bool]
    channels: NotRequired[int]
    r"""Number of audio channels (for audio streams)."""
    audio_channel_layout: NotRequired[str]
    r"""Audio channel layout."""
    sampling_rate: NotRequired[int]
    r"""Sampling rate for the audio stream."""
    can_auto_sync: NotRequired[bool]
    r"""Indicates if the stream can auto-sync."""
    hearing_impaired: NotRequired[bool]
    r"""Indicates if the stream is for the hearing impaired."""
    dub: NotRequired[bool]
    r"""Indicates if the stream is a dub."""
    title: NotRequired[str]
    r"""Optional title for the stream (e.g., language variant)."""


class GetLibrarySectionsAllStream(BaseModel):
    id: int
    r"""Unique stream identifier."""

    codec: str
    r"""Codec used by the stream."""

    display_title: Annotated[str, pydantic.Field(alias="displayTitle")]
    r"""Display title for the stream."""

    extended_display_title: Annotated[str, pydantic.Field(alias="extendedDisplayTitle")]
    r"""Extended display title for the stream."""

    STREAM_TYPE: Annotated[
        Annotated[Literal[1], AfterValidator(validate_const(1))],
        pydantic.Field(alias="streamType"),
    ] = 1
    r"""Stream type:
    - VIDEO = 1
    - AUDIO = 2
    - SUBTITLE = 3

    """

    format_: Annotated[Optional[str], pydantic.Field(alias="format")] = None
    r"""Format of the stream (e.g., srt)."""

    default: Optional[bool] = None
    r"""Indicates if this stream is default."""

    index: Optional[int] = None
    r"""Index of the stream."""

    bitrate: Optional[int] = None
    r"""Bitrate of the stream."""

    language: Optional[str] = None
    r"""Language of the stream."""

    language_tag: Annotated[Optional[str], pydantic.Field(alias="languageTag")] = None
    r"""Language tag (e.g., en)."""

    language_code: Annotated[Optional[str], pydantic.Field(alias="languageCode")] = None
    r"""ISO language code."""

    header_compression: Annotated[
        Optional[bool], pydantic.Field(alias="headerCompression")
    ] = None
    r"""Indicates whether header compression is enabled."""

    dovibl_compat_id: Annotated[
        Optional[int], pydantic.Field(alias="DOVIBLCompatID")
    ] = None
    r"""Dolby Vision BL compatibility ID."""

    dovibl_present: Annotated[Optional[bool], pydantic.Field(alias="DOVIBLPresent")] = (
        None
    )
    r"""Indicates if Dolby Vision BL is present."""

    doviel_present: Annotated[Optional[bool], pydantic.Field(alias="DOVIELPresent")] = (
        None
    )
    r"""Indicates if Dolby Vision EL is present."""

    dovi_level: Annotated[Optional[int], pydantic.Field(alias="DOVILevel")] = None
    r"""Dolby Vision level."""

    dovi_present: Annotated[Optional[bool], pydantic.Field(alias="DOVIPresent")] = None
    r"""Indicates if Dolby Vision is present."""

    dovi_profile: Annotated[Optional[int], pydantic.Field(alias="DOVIProfile")] = None
    r"""Dolby Vision profile."""

    dovirpu_present: Annotated[
        Optional[bool], pydantic.Field(alias="DOVIRPUPresent")
    ] = None
    r"""Indicates if Dolby Vision RPU is present."""

    dovi_version: Annotated[Optional[str], pydantic.Field(alias="DOVIVersion")] = None
    r"""Dolby Vision version."""

    bit_depth: Annotated[Optional[int], pydantic.Field(alias="bitDepth")] = None
    r"""Bit depth of the video stream."""

    chroma_location: Annotated[
        Optional[str], pydantic.Field(alias="chromaLocation")
    ] = None
    r"""Chroma sample location."""

    chroma_subsampling: Annotated[
        Optional[str], pydantic.Field(alias="chromaSubsampling")
    ] = None
    r"""Chroma subsampling format."""

    coded_height: Annotated[Optional[int], pydantic.Field(alias="codedHeight")] = None
    r"""Coded video height."""

    coded_width: Annotated[Optional[int], pydantic.Field(alias="codedWidth")] = None
    r"""Coded video width."""

    closed_captions: Annotated[
        Optional[bool], pydantic.Field(alias="closedCaptions")
    ] = None

    color_primaries: Annotated[
        Optional[str], pydantic.Field(alias="colorPrimaries")
    ] = None
    r"""Color primaries used."""

    color_range: Annotated[Optional[str], pydantic.Field(alias="colorRange")] = None
    r"""Color range (e.g., tv)."""

    color_space: Annotated[Optional[str], pydantic.Field(alias="colorSpace")] = None
    r"""Color space."""

    color_trc: Annotated[Optional[str], pydantic.Field(alias="colorTrc")] = None
    r"""Color transfer characteristics."""

    frame_rate: Annotated[Optional[float], pydantic.Field(alias="frameRate")] = None
    r"""Frame rate of the stream."""

    key: Optional[str] = None
    r"""Key to access this stream part."""

    height: Optional[int] = None
    r"""Height of the video stream."""

    level: Optional[int] = None
    r"""Video level."""

    original: Optional[bool] = None
    r"""Indicates if this is the original stream."""

    has_scaling_matrix: Annotated[
        Optional[bool], pydantic.Field(alias="hasScalingMatrix")
    ] = None

    profile: Optional[str] = None
    r"""Video profile."""

    scan_type: Annotated[Optional[str], pydantic.Field(alias="scanType")] = None

    embedded_in_video: Annotated[
        Optional[str], pydantic.Field(alias="embeddedInVideo")
    ] = None

    ref_frames: Annotated[Optional[int], pydantic.Field(alias="refFrames")] = None
    r"""Number of reference frames."""

    width: Optional[int] = None
    r"""Width of the video stream."""

    selected: Optional[bool] = None
    r"""Indicates if this stream is selected (applicable for audio streams)."""

    forced: Optional[bool] = None

    channels: Optional[int] = None
    r"""Number of audio channels (for audio streams)."""

    audio_channel_layout: Annotated[
        Optional[str], pydantic.Field(alias="audioChannelLayout")
    ] = None
    r"""Audio channel layout."""

    sampling_rate: Annotated[Optional[int], pydantic.Field(alias="samplingRate")] = None
    r"""Sampling rate for the audio stream."""

    can_auto_sync: Annotated[Optional[bool], pydantic.Field(alias="canAutoSync")] = None
    r"""Indicates if the stream can auto-sync."""

    hearing_impaired: Annotated[
        Optional[bool], pydantic.Field(alias="hearingImpaired")
    ] = None
    r"""Indicates if the stream is for the hearing impaired."""

    dub: Optional[bool] = None
    r"""Indicates if the stream is a dub."""

    title: Optional[str] = None
    r"""Optional title for the stream (e.g., language variant)."""


class GetLibrarySectionsAllPartTypedDict(TypedDict):
    id: int
    r"""Unique part identifier."""
    key: str
    r"""Key to access this part."""
    file: str
    r"""File path for the part."""
    size: int
    r"""File size in bytes."""
    accessible: NotRequired[bool]
    r"""Indicates if the part is accessible."""
    exists: NotRequired[bool]
    r"""Indicates if the part exists."""
    indexes: NotRequired[str]
    duration: NotRequired[int]
    r"""Duration of the part in milliseconds."""
    packet_length: NotRequired[int]
    container: NotRequired[str]
    r"""Container format of the part."""
    video_profile: NotRequired[str]
    r"""Video profile for the part."""
    audio_profile: NotRequired[str]
    r"""The audio profile used for the media (e.g., DTS, Dolby Digital, etc.)."""
    has64bit_offsets: NotRequired[bool]
    optimized_for_streaming: NotRequired[
        GetLibrarySectionsAllLibraryOptimizedForStreamingTypedDict
    ]
    r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""
    has_thumbnail: NotRequired[GetLibrarySectionsAllHasThumbnail]
    stream: NotRequired[List[GetLibrarySectionsAllStreamTypedDict]]
    r"""An array of streams for this part."""


class GetLibrarySectionsAllPart(BaseModel):
    id: int
    r"""Unique part identifier."""

    key: str
    r"""Key to access this part."""

    file: str
    r"""File path for the part."""

    size: int
    r"""File size in bytes."""

    accessible: Optional[bool] = None
    r"""Indicates if the part is accessible."""

    exists: Optional[bool] = None
    r"""Indicates if the part exists."""

    indexes: Optional[str] = None

    duration: Optional[int] = None
    r"""Duration of the part in milliseconds."""

    packet_length: Annotated[Optional[int], pydantic.Field(alias="packetLength")] = None

    container: Optional[str] = None
    r"""Container format of the part."""

    video_profile: Annotated[Optional[str], pydantic.Field(alias="videoProfile")] = None
    r"""Video profile for the part."""

    audio_profile: Annotated[Optional[str], pydantic.Field(alias="audioProfile")] = None
    r"""The audio profile used for the media (e.g., DTS, Dolby Digital, etc.)."""

    has64bit_offsets: Annotated[
        Optional[bool], pydantic.Field(alias="has64bitOffsets")
    ] = None

    optimized_for_streaming: Annotated[
        Optional[GetLibrarySectionsAllLibraryOptimizedForStreaming],
        pydantic.Field(alias="optimizedForStreaming"),
    ] = None
    r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""

    has_thumbnail: Annotated[
        Optional[GetLibrarySectionsAllHasThumbnail],
        pydantic.Field(alias="hasThumbnail"),
    ] = GetLibrarySectionsAllHasThumbnail.FALSE

    stream: Annotated[
        Optional[List[GetLibrarySectionsAllStream]], pydantic.Field(alias="Stream")
    ] = None
    r"""An array of streams for this part."""


class GetLibrarySectionsAllMediaTypedDict(TypedDict):
    id: int
    r"""Unique media identifier."""
    duration: NotRequired[int]
    r"""Duration of the media in milliseconds."""
    bitrate: NotRequired[int]
    r"""Bitrate in bits per second."""
    width: NotRequired[int]
    r"""Video width in pixels."""
    height: NotRequired[int]
    r"""Video height in pixels."""
    aspect_ratio: NotRequired[float]
    r"""Aspect ratio of the video."""
    audio_channels: NotRequired[int]
    r"""Number of audio channels."""
    display_offset: NotRequired[int]
    audio_codec: NotRequired[str]
    r"""Audio codec used."""
    video_codec: NotRequired[str]
    r"""Video codec used."""
    video_resolution: NotRequired[str]
    r"""Video resolution (e.g., 4k)."""
    container: NotRequired[str]
    r"""File container type."""
    video_frame_rate: NotRequired[str]
    r"""Frame rate of the video. Values found include NTSC, PAL, 24p

    """
    video_profile: NotRequired[str]
    r"""Video profile (e.g., main 10)."""
    has_voice_activity: NotRequired[bool]
    r"""Indicates whether voice activity is detected."""
    audio_profile: NotRequired[str]
    r"""The audio profile used for the media (e.g., DTS, Dolby Digital, etc.)."""
    optimized_for_streaming: NotRequired[
        GetLibrarySectionsAllOptimizedForStreamingTypedDict
    ]
    r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""
    has64bit_offsets: NotRequired[bool]
    part: NotRequired[List[GetLibrarySectionsAllPartTypedDict]]
    r"""An array of parts for this media item."""


class GetLibrarySectionsAllMedia(BaseModel):
    id: int
    r"""Unique media identifier."""

    duration: Optional[int] = None
    r"""Duration of the media in milliseconds."""

    bitrate: Optional[int] = None
    r"""Bitrate in bits per second."""

    width: Optional[int] = None
    r"""Video width in pixels."""

    height: Optional[int] = None
    r"""Video height in pixels."""

    aspect_ratio: Annotated[Optional[float], pydantic.Field(alias="aspectRatio")] = None
    r"""Aspect ratio of the video."""

    audio_channels: Annotated[Optional[int], pydantic.Field(alias="audioChannels")] = (
        None
    )
    r"""Number of audio channels."""

    display_offset: Annotated[Optional[int], pydantic.Field(alias="displayOffset")] = (
        None
    )

    audio_codec: Annotated[Optional[str], pydantic.Field(alias="audioCodec")] = None
    r"""Audio codec used."""

    video_codec: Annotated[Optional[str], pydantic.Field(alias="videoCodec")] = None
    r"""Video codec used."""

    video_resolution: Annotated[
        Optional[str], pydantic.Field(alias="videoResolution")
    ] = None
    r"""Video resolution (e.g., 4k)."""

    container: Optional[str] = None
    r"""File container type."""

    video_frame_rate: Annotated[
        Optional[str], pydantic.Field(alias="videoFrameRate")
    ] = None
    r"""Frame rate of the video. Values found include NTSC, PAL, 24p

    """

    video_profile: Annotated[Optional[str], pydantic.Field(alias="videoProfile")] = None
    r"""Video profile (e.g., main 10)."""

    has_voice_activity: Annotated[
        Optional[bool], pydantic.Field(alias="hasVoiceActivity")
    ] = None
    r"""Indicates whether voice activity is detected."""

    audio_profile: Annotated[Optional[str], pydantic.Field(alias="audioProfile")] = None
    r"""The audio profile used for the media (e.g., DTS, Dolby Digital, etc.)."""

    optimized_for_streaming: Annotated[
        Optional[GetLibrarySectionsAllOptimizedForStreaming],
        pydantic.Field(alias="optimizedForStreaming"),
    ] = None
    r"""Has this media been optimized for streaming. NOTE: This can be 0, 1, false or true"""

    has64bit_offsets: Annotated[
        Optional[bool], pydantic.Field(alias="has64bitOffsets")
    ] = None

    part: Annotated[
        Optional[List[GetLibrarySectionsAllPart]], pydantic.Field(alias="Part")
    ] = None
    r"""An array of parts for this media item."""


class GetLibrarySectionsAllGenreTypedDict(TypedDict):
    tag: str
    r"""The genre name of this media-item

    """


class GetLibrarySectionsAllGenre(BaseModel):
    tag: str
    r"""The genre name of this media-item

    """


class GetLibrarySectionsAllCountryTypedDict(TypedDict):
    tag: str
    r"""The country of origin of this media item"""


class GetLibrarySectionsAllCountry(BaseModel):
    tag: str
    r"""The country of origin of this media item"""


class GetLibrarySectionsAllDirectorTypedDict(TypedDict):
    tag: str
    r"""The role of Director"""


class GetLibrarySectionsAllDirector(BaseModel):
    tag: str
    r"""The role of Director"""


class GetLibrarySectionsAllWriterTypedDict(TypedDict):
    tag: str
    r"""The role of Writer"""


class GetLibrarySectionsAllWriter(BaseModel):
    tag: str
    r"""The role of Writer"""


class GetLibrarySectionsAllRoleTypedDict(TypedDict):
    tag: str
    r"""The display tag for the actor (typically the actor's name)."""


class GetLibrarySectionsAllRole(BaseModel):
    tag: str
    r"""The display tag for the actor (typically the actor's name)."""


class GetLibrarySectionsAllCollectionTypedDict(TypedDict):
    tag: str
    r"""The user-made collection this media item belongs to"""


class GetLibrarySectionsAllCollection(BaseModel):
    tag: str
    r"""The user-made collection this media item belongs to"""


class GetLibrarySectionsAllMetadataTypedDict(TypedDict):
    r"""Unknown"""

    rating_key: str
    r"""The rating key (Media ID) of this media item. Note: Although this is always an integer, it is represented as a string in the API."""
    key: str
    r"""The unique key for the media item."""
    guid: str
    r"""The globally unique identifier for the media item."""
    slug: str
    r"""A URL‐friendly version of the media title."""
    type: GetLibrarySectionsAllLibraryType
    title: str
    r"""The title of the media item."""
    title_sort: str
    r"""The sort title used for ordering media items."""
    summary: str
    r"""A synopsis of the media item."""
    rating: float
    r"""The critic rating for the media item."""
    audience_rating: float
    r"""The audience rating for the media item."""
    tagline: str
    r"""A brief tagline for the media item."""
    thumb: str
    r"""The thumbnail image URL for the media item."""
    art: str
    r"""The art image URL for the media item."""
    theme: str
    r"""The theme URL for the media item."""
    index: int
    r"""The index position of the media item."""
    child_count: int
    r"""The number of child items associated with this media item."""
    season_count: int
    r"""The total number of seasons (for TV shows)."""
    duration: int
    r"""The duration of the media item in milliseconds."""
    added_at: int
    studio: NotRequired[str]
    r"""The studio that produced the media item."""
    content_rating: NotRequired[str]
    r"""The content rating for the media item."""
    year: NotRequired[int]
    r"""The release year of the media item."""
    leaf_count: NotRequired[int]
    r"""The number of leaf items (end nodes) under this media item."""
    viewed_leaf_count: NotRequired[int]
    r"""The number of leaf items that have been viewed."""
    originally_available_at: NotRequired[date]
    r"""The original release date of the media item."""
    updated_at: NotRequired[int]
    r"""Unix epoch datetime in seconds"""
    audience_rating_image: NotRequired[str]
    r"""The URL for the audience rating image."""
    chapter_source: NotRequired[str]
    r"""The source from which chapter data is derived."""
    primary_extra_key: NotRequired[str]
    r"""The primary extra key associated with this media item."""
    original_title: NotRequired[str]
    r"""The original title of the media item (if different)."""
    parent_rating_key: NotRequired[str]
    r"""The rating key of the parent media item."""
    grandparent_rating_key: NotRequired[str]
    r"""The rating key of the grandparent media item."""
    parent_guid: NotRequired[str]
    r"""The GUID of the parent media item."""
    grandparent_guid: NotRequired[str]
    r"""The GUID of the grandparent media item."""
    grandparent_slug: NotRequired[str]
    r"""The slug for the grandparent media item."""
    grandparent_key: NotRequired[str]
    r"""The key of the grandparent media item."""
    parent_key: NotRequired[str]
    r"""The key of the parent media item."""
    grandparent_title: NotRequired[str]
    r"""The title of the grandparent media item."""
    grandparent_thumb: NotRequired[str]
    r"""The thumbnail URL for the grandparent media item."""
    grandparent_theme: NotRequired[str]
    r"""The theme URL for the grandparent media item."""
    grandparent_art: NotRequired[str]
    r"""The art URL for the grandparent media item."""
    parent_title: NotRequired[str]
    r"""The title of the parent media item."""
    parent_index: NotRequired[int]
    r"""The index position of the parent media item."""
    parent_thumb: NotRequired[str]
    r"""The thumbnail URL for the parent media item."""
    rating_image: NotRequired[str]
    r"""The URL for the rating image."""
    view_count: NotRequired[int]
    r"""The number of times this media item has been viewed."""
    view_offset: NotRequired[int]
    r"""The current playback offset (in milliseconds)."""
    skip_count: NotRequired[int]
    r"""The number of times this media item has been skipped."""
    subtype: NotRequired[str]
    r"""A classification that further describes the type of media item. For example, 'clip' indicates that the item is a short video clip."""
    last_rated_at: NotRequired[int]
    r"""The Unix timestamp representing the last time the item was rated."""
    created_at_accuracy: NotRequired[str]
    r"""The accuracy of the creation timestamp. This value indicates the format(s) provided (for example, 'epoch,local' means both epoch and local time formats are available)."""
    created_at_tz_offset: NotRequired[str]
    r"""The time zone offset for the creation timestamp, represented as a string. This offset indicates the difference from UTC."""
    last_viewed_at: NotRequired[int]
    r"""Unix timestamp for when the media item was last viewed."""
    user_rating: NotRequired[float]
    r"""The rating provided by a user for the item. This value is expressed as a decimal number."""
    image: NotRequired[List[GetLibrarySectionsAllImageTypedDict]]
    ultra_blur_colors: NotRequired[GetLibrarySectionsAllUltraBlurColorsTypedDict]
    guids: NotRequired[List[GetLibrarySectionsAllGuidsTypedDict]]
    media: NotRequired[List[GetLibrarySectionsAllMediaTypedDict]]
    genre: NotRequired[List[GetLibrarySectionsAllGenreTypedDict]]
    country: NotRequired[List[GetLibrarySectionsAllCountryTypedDict]]
    director: NotRequired[List[GetLibrarySectionsAllDirectorTypedDict]]
    writer: NotRequired[List[GetLibrarySectionsAllWriterTypedDict]]
    role: NotRequired[List[GetLibrarySectionsAllRoleTypedDict]]
    collection: NotRequired[List[GetLibrarySectionsAllCollectionTypedDict]]


class GetLibrarySectionsAllMetadata(BaseModel):
    r"""Unknown"""

    rating_key: Annotated[str, pydantic.Field(alias="ratingKey")]
    r"""The rating key (Media ID) of this media item. Note: Although this is always an integer, it is represented as a string in the API."""

    key: str
    r"""The unique key for the media item."""

    guid: str
    r"""The globally unique identifier for the media item."""

    slug: str
    r"""A URL‐friendly version of the media title."""

    type: Annotated[
        GetLibrarySectionsAllLibraryType, PlainValidator(validate_open_enum(False))
    ]

    title: str
    r"""The title of the media item."""

    title_sort: Annotated[str, pydantic.Field(alias="titleSort")]
    r"""The sort title used for ordering media items."""

    summary: str
    r"""A synopsis of the media item."""

    rating: float
    r"""The critic rating for the media item."""

    audience_rating: Annotated[float, pydantic.Field(alias="audienceRating")]
    r"""The audience rating for the media item."""

    tagline: str
    r"""A brief tagline for the media item."""

    thumb: str
    r"""The thumbnail image URL for the media item."""

    art: str
    r"""The art image URL for the media item."""

    theme: str
    r"""The theme URL for the media item."""

    index: int
    r"""The index position of the media item."""

    child_count: Annotated[int, pydantic.Field(alias="childCount")]
    r"""The number of child items associated with this media item."""

    season_count: Annotated[int, pydantic.Field(alias="seasonCount")]
    r"""The total number of seasons (for TV shows)."""

    duration: int
    r"""The duration of the media item in milliseconds."""

    added_at: Annotated[int, pydantic.Field(alias="addedAt")]

    studio: Optional[str] = None
    r"""The studio that produced the media item."""

    content_rating: Annotated[Optional[str], pydantic.Field(alias="contentRating")] = (
        None
    )
    r"""The content rating for the media item."""

    year: Optional[int] = None
    r"""The release year of the media item."""

    leaf_count: Annotated[Optional[int], pydantic.Field(alias="leafCount")] = None
    r"""The number of leaf items (end nodes) under this media item."""

    viewed_leaf_count: Annotated[
        Optional[int], pydantic.Field(alias="viewedLeafCount")
    ] = None
    r"""The number of leaf items that have been viewed."""

    originally_available_at: Annotated[
        Optional[date], pydantic.Field(alias="originallyAvailableAt")
    ] = None
    r"""The original release date of the media item."""

    updated_at: Annotated[Optional[int], pydantic.Field(alias="updatedAt")] = None
    r"""Unix epoch datetime in seconds"""

    audience_rating_image: Annotated[
        Optional[str], pydantic.Field(alias="audienceRatingImage")
    ] = None
    r"""The URL for the audience rating image."""

    chapter_source: Annotated[Optional[str], pydantic.Field(alias="chapterSource")] = (
        None
    )
    r"""The source from which chapter data is derived."""

    primary_extra_key: Annotated[
        Optional[str], pydantic.Field(alias="primaryExtraKey")
    ] = None
    r"""The primary extra key associated with this media item."""

    original_title: Annotated[Optional[str], pydantic.Field(alias="originalTitle")] = (
        None
    )
    r"""The original title of the media item (if different)."""

    parent_rating_key: Annotated[
        Optional[str], pydantic.Field(alias="parentRatingKey")
    ] = None
    r"""The rating key of the parent media item."""

    grandparent_rating_key: Annotated[
        Optional[str], pydantic.Field(alias="grandparentRatingKey")
    ] = None
    r"""The rating key of the grandparent media item."""

    parent_guid: Annotated[Optional[str], pydantic.Field(alias="parentGuid")] = None
    r"""The GUID of the parent media item."""

    grandparent_guid: Annotated[
        Optional[str], pydantic.Field(alias="grandparentGuid")
    ] = None
    r"""The GUID of the grandparent media item."""

    grandparent_slug: Annotated[
        Optional[str], pydantic.Field(alias="grandparentSlug")
    ] = None
    r"""The slug for the grandparent media item."""

    grandparent_key: Annotated[
        Optional[str], pydantic.Field(alias="grandparentKey")
    ] = None
    r"""The key of the grandparent media item."""

    parent_key: Annotated[Optional[str], pydantic.Field(alias="parentKey")] = None
    r"""The key of the parent media item."""

    grandparent_title: Annotated[
        Optional[str], pydantic.Field(alias="grandparentTitle")
    ] = None
    r"""The title of the grandparent media item."""

    grandparent_thumb: Annotated[
        Optional[str], pydantic.Field(alias="grandparentThumb")
    ] = None
    r"""The thumbnail URL for the grandparent media item."""

    grandparent_theme: Annotated[
        Optional[str], pydantic.Field(alias="grandparentTheme")
    ] = None
    r"""The theme URL for the grandparent media item."""

    grandparent_art: Annotated[
        Optional[str], pydantic.Field(alias="grandparentArt")
    ] = None
    r"""The art URL for the grandparent media item."""

    parent_title: Annotated[Optional[str], pydantic.Field(alias="parentTitle")] = None
    r"""The title of the parent media item."""

    parent_index: Annotated[Optional[int], pydantic.Field(alias="parentIndex")] = None
    r"""The index position of the parent media item."""

    parent_thumb: Annotated[Optional[str], pydantic.Field(alias="parentThumb")] = None
    r"""The thumbnail URL for the parent media item."""

    rating_image: Annotated[Optional[str], pydantic.Field(alias="ratingImage")] = None
    r"""The URL for the rating image."""

    view_count: Annotated[Optional[int], pydantic.Field(alias="viewCount")] = None
    r"""The number of times this media item has been viewed."""

    view_offset: Annotated[Optional[int], pydantic.Field(alias="viewOffset")] = None
    r"""The current playback offset (in milliseconds)."""

    skip_count: Annotated[Optional[int], pydantic.Field(alias="skipCount")] = None
    r"""The number of times this media item has been skipped."""

    subtype: Optional[str] = None
    r"""A classification that further describes the type of media item. For example, 'clip' indicates that the item is a short video clip."""

    last_rated_at: Annotated[Optional[int], pydantic.Field(alias="lastRatedAt")] = None
    r"""The Unix timestamp representing the last time the item was rated."""

    created_at_accuracy: Annotated[
        Optional[str], pydantic.Field(alias="createdAtAccuracy")
    ] = None
    r"""The accuracy of the creation timestamp. This value indicates the format(s) provided (for example, 'epoch,local' means both epoch and local time formats are available)."""

    created_at_tz_offset: Annotated[
        Optional[str], pydantic.Field(alias="createdAtTZOffset")
    ] = None
    r"""The time zone offset for the creation timestamp, represented as a string. This offset indicates the difference from UTC."""

    last_viewed_at: Annotated[Optional[int], pydantic.Field(alias="lastViewedAt")] = (
        None
    )
    r"""Unix timestamp for when the media item was last viewed."""

    user_rating: Annotated[Optional[float], pydantic.Field(alias="userRating")] = None
    r"""The rating provided by a user for the item. This value is expressed as a decimal number."""

    image: Annotated[
        Optional[List[GetLibrarySectionsAllImage]], pydantic.Field(alias="Image")
    ] = None

    ultra_blur_colors: Annotated[
        Optional[GetLibrarySectionsAllUltraBlurColors],
        pydantic.Field(alias="UltraBlurColors"),
    ] = None

    guids: Annotated[
        Optional[List[GetLibrarySectionsAllGuids]], pydantic.Field(alias="Guid")
    ] = None

    media: Annotated[
        Optional[List[GetLibrarySectionsAllMedia]], pydantic.Field(alias="Media")
    ] = None

    genre: Annotated[
        Optional[List[GetLibrarySectionsAllGenre]], pydantic.Field(alias="Genre")
    ] = None

    country: Annotated[
        Optional[List[GetLibrarySectionsAllCountry]], pydantic.Field(alias="Country")
    ] = None

    director: Annotated[
        Optional[List[GetLibrarySectionsAllDirector]], pydantic.Field(alias="Director")
    ] = None

    writer: Annotated[
        Optional[List[GetLibrarySectionsAllWriter]], pydantic.Field(alias="Writer")
    ] = None

    role: Annotated[
        Optional[List[GetLibrarySectionsAllRole]], pydantic.Field(alias="Role")
    ] = None

    collection: Annotated[
        Optional[List[GetLibrarySectionsAllCollection]],
        pydantic.Field(alias="Collection"),
    ] = None


class GetLibrarySectionsAllMediaContainerTypedDict(TypedDict):
    size: int
    r"""Number of media items returned in this response."""
    total_size: int
    r"""Total number of media items in the library."""
    offset: int
    r"""Offset value for pagination."""
    allow_sync: bool
    r"""Indicates whether syncing is allowed."""
    art: str
    r"""URL for the background artwork of the media container."""
    content: str
    r"""The content type or mode."""
    identifier: str
    r"""An plugin identifier for the media container."""
    media_tag_prefix: str
    r"""The prefix used for media tag resource paths."""
    media_tag_version: int
    r"""The version number for media tags."""
    thumb: str
    r"""URL for the thumbnail image of the media container."""
    nocache: bool
    r"""Specifies whether caching is disabled."""
    title1: str
    r"""The primary title of the media container."""
    title2: str
    r"""The secondary title of the media container."""
    view_group: str
    r"""Identifier for the view group layout."""
    library_section_id: NotRequired[int]
    r"""The unique identifier for the library section."""
    library_section_title: NotRequired[str]
    r"""The title of the library section."""
    library_section_uuid: NotRequired[str]
    r"""The universally unique identifier for the library section."""
    meta: NotRequired[GetLibrarySectionsAllMetaTypedDict]
    r"""The Meta object is only included in the response if the `includeMeta` parameter is set to `1`.

    """
    metadata: NotRequired[List[GetLibrarySectionsAllMetadataTypedDict]]
    r"""An array of metadata items."""


class GetLibrarySectionsAllMediaContainer(BaseModel):
    size: int
    r"""Number of media items returned in this response."""

    total_size: Annotated[int, pydantic.Field(alias="totalSize")]
    r"""Total number of media items in the library."""

    offset: int
    r"""Offset value for pagination."""

    allow_sync: Annotated[bool, pydantic.Field(alias="allowSync")]
    r"""Indicates whether syncing is allowed."""

    art: str
    r"""URL for the background artwork of the media container."""

    content: str
    r"""The content type or mode."""

    identifier: str
    r"""An plugin identifier for the media container."""

    media_tag_prefix: Annotated[str, pydantic.Field(alias="mediaTagPrefix")]
    r"""The prefix used for media tag resource paths."""

    media_tag_version: Annotated[int, pydantic.Field(alias="mediaTagVersion")]
    r"""The version number for media tags."""

    thumb: str
    r"""URL for the thumbnail image of the media container."""

    nocache: bool
    r"""Specifies whether caching is disabled."""

    title1: str
    r"""The primary title of the media container."""

    title2: str
    r"""The secondary title of the media container."""

    view_group: Annotated[str, pydantic.Field(alias="viewGroup")]
    r"""Identifier for the view group layout."""

    library_section_id: Annotated[
        Optional[int], pydantic.Field(alias="librarySectionID")
    ] = None
    r"""The unique identifier for the library section."""

    library_section_title: Annotated[
        Optional[str], pydantic.Field(alias="librarySectionTitle")
    ] = None
    r"""The title of the library section."""

    library_section_uuid: Annotated[
        Optional[str], pydantic.Field(alias="librarySectionUUID")
    ] = None
    r"""The universally unique identifier for the library section."""

    meta: Annotated[
        Optional[GetLibrarySectionsAllMeta], pydantic.Field(alias="Meta")
    ] = None
    r"""The Meta object is only included in the response if the `includeMeta` parameter is set to `1`.

    """

    metadata: Annotated[
        Optional[List[GetLibrarySectionsAllMetadata]], pydantic.Field(alias="Metadata")
    ] = None
    r"""An array of metadata items."""


class GetLibrarySectionsAllResponseBodyTypedDict(TypedDict):
    r"""Successful response containing media container data."""

    media_container: NotRequired[GetLibrarySectionsAllMediaContainerTypedDict]


class GetLibrarySectionsAllResponseBody(BaseModel):
    r"""Successful response containing media container data."""

    media_container: Annotated[
        Optional[GetLibrarySectionsAllMediaContainer],
        pydantic.Field(alias="MediaContainer"),
    ] = None


class GetLibrarySectionsAllResponseTypedDict(TypedDict):
    content_type: str
    r"""HTTP response content type for this operation"""
    status_code: int
    r"""HTTP response status code for this operation"""
    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""
    object: NotRequired[GetLibrarySectionsAllResponseBodyTypedDict]
    r"""Successful response containing media container data."""


class GetLibrarySectionsAllResponse(BaseModel):
    content_type: str
    r"""HTTP response content type for this operation"""

    status_code: int
    r"""HTTP response status code for this operation"""

    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""

    object: Optional[GetLibrarySectionsAllResponseBody] = None
    r"""Successful response containing media container data."""
