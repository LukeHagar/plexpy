"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import date
from enum import Enum
import httpx
from plex_api_client import utils
from plex_api_client.types import BaseModel
from plex_api_client.utils import (
    FieldMetadata,
    HeaderMetadata,
    PathParamMetadata,
    QueryParamMetadata,
    validate_open_enum,
)
import pydantic
from pydantic.functional_validators import PlainValidator
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


GET_WATCH_LIST_SERVERS = [
    # The plex metadata provider server
    "https://metadata.provider.plex.tv",
]


class Filter(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Filter"""

    ALL = "all"
    AVAILABLE = "available"
    RELEASED = "released"


class Libtype(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The type of library to filter. Can be \"movie\" or \"show\", or all if not present."""

    MOVIE = "movie"
    SHOW = "show"


class IncludeCollections(int, Enum):
    r"""include collections in the results"""

    ONE = 1
    ZERO = 0


class IncludeExternalMedia(int, Enum):
    r"""include external media in the results"""

    ONE = 1
    ZERO = 0


class GetWatchListRequestTypedDict(TypedDict):
    filter_: Filter
    r"""Filter"""
    x_plex_token: str
    r"""An authentication token, obtained from plex.tv"""
    sort: NotRequired[str]
    r"""In the format \"field:dir\". Available fields are \"watchlistedAt\" (Added At),
    \"titleSort\" (Title), \"originallyAvailableAt\" (Release Date), or \"rating\" (Critic Rating).
    \"dir\" can be \"asc\" or \"desc\" 

    """
    libtype: NotRequired[Libtype]
    r"""The type of library to filter. Can be \"movie\" or \"show\", or all if not present.

    """
    maxresults: NotRequired[int]
    r"""The number of items to return. If not specified, all items will be returned.
    If the number of items exceeds the limit, the response will be paginated.

    """
    include_collections: NotRequired[IncludeCollections]
    r"""include collections in the results

    """
    include_external_media: NotRequired[IncludeExternalMedia]
    r"""include external media in the results

    """
    x_plex_container_start: NotRequired[int]
    r"""The index of the first item to return. If not specified, the first item will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 0

    """
    x_plex_container_size: NotRequired[int]
    r"""The number of items to return. If not specified, all items will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 50

    """


class GetWatchListRequest(BaseModel):
    filter_: Annotated[
        Annotated[Filter, PlainValidator(validate_open_enum(False))],
        pydantic.Field(alias="filter"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""Filter"""

    x_plex_token: Annotated[
        str,
        pydantic.Field(alias="X-Plex-Token"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ]
    r"""An authentication token, obtained from plex.tv"""

    sort: Annotated[
        Optional[str],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""In the format \"field:dir\". Available fields are \"watchlistedAt\" (Added At),
    \"titleSort\" (Title), \"originallyAvailableAt\" (Release Date), or \"rating\" (Critic Rating).
    \"dir\" can be \"asc\" or \"desc\" 

    """

    libtype: Annotated[
        Annotated[Optional[Libtype], PlainValidator(validate_open_enum(False))],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""The type of library to filter. Can be \"movie\" or \"show\", or all if not present.

    """

    maxresults: Annotated[
        Optional[int],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""The number of items to return. If not specified, all items will be returned.
    If the number of items exceeds the limit, the response will be paginated.

    """

    include_collections: Annotated[
        Optional[IncludeCollections],
        pydantic.Field(alias="includeCollections"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""include collections in the results

    """

    include_external_media: Annotated[
        Optional[IncludeExternalMedia],
        pydantic.Field(alias="includeExternalMedia"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""include external media in the results

    """

    x_plex_container_start: Annotated[
        Optional[int],
        pydantic.Field(alias="X-Plex-Container-Start"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 0
    r"""The index of the first item to return. If not specified, the first item will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 0

    """

    x_plex_container_size: Annotated[
        Optional[int],
        pydantic.Field(alias="X-Plex-Container-Size"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 50
    r"""The number of items to return. If not specified, all items will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 50

    """


class ImageTypedDict(TypedDict):
    alt: NotRequired[str]
    type: NotRequired[str]
    url: NotRequired[str]


class Image(BaseModel):
    alt: Optional[str] = None

    type: Optional[str] = None

    url: Optional[str] = None


class MetadataTypedDict(TypedDict):
    art: NotRequired[str]
    guid: NotRequired[str]
    key: NotRequired[str]
    rating_key: NotRequired[str]
    studio: NotRequired[str]
    tagline: NotRequired[str]
    type: NotRequired[str]
    thumb: NotRequired[str]
    added_at: NotRequired[int]
    duration: NotRequired[int]
    public_pages_url: NotRequired[str]
    slug: NotRequired[str]
    user_state: NotRequired[bool]
    title: NotRequired[str]
    content_rating: NotRequired[str]
    originally_available_at: NotRequired[date]
    year: NotRequired[int]
    image: NotRequired[List[ImageTypedDict]]
    banner: NotRequired[str]
    rating: NotRequired[float]
    expires_at: NotRequired[int]
    original_title: NotRequired[str]
    audience_rating: NotRequired[float]
    audience_rating_image: NotRequired[str]
    rating_image: NotRequired[str]
    imdb_rating_count: NotRequired[int]
    subtype: NotRequired[str]
    theme: NotRequired[str]
    leaf_count: NotRequired[int]
    child_count: NotRequired[int]
    is_continuing_series: NotRequired[bool]
    skip_children: NotRequired[bool]
    availability_id: NotRequired[str]
    streaming_media_id: NotRequired[str]
    playable_key: NotRequired[str]


class Metadata(BaseModel):
    art: Optional[str] = None

    guid: Optional[str] = None

    key: Optional[str] = None

    rating_key: Annotated[Optional[str], pydantic.Field(alias="ratingKey")] = None

    studio: Optional[str] = None

    tagline: Optional[str] = None

    type: Optional[str] = None

    thumb: Optional[str] = None

    added_at: Annotated[Optional[int], pydantic.Field(alias="addedAt")] = None

    duration: Optional[int] = None

    public_pages_url: Annotated[
        Optional[str], pydantic.Field(alias="publicPagesURL")
    ] = None

    slug: Optional[str] = None

    user_state: Annotated[Optional[bool], pydantic.Field(alias="userState")] = None

    title: Optional[str] = None

    content_rating: Annotated[Optional[str], pydantic.Field(alias="contentRating")] = (
        None
    )

    originally_available_at: Annotated[
        Optional[date], pydantic.Field(alias="originallyAvailableAt")
    ] = None

    year: Optional[int] = None

    image: Annotated[Optional[List[Image]], pydantic.Field(alias="Image")] = None

    banner: Optional[str] = None

    rating: Optional[float] = None

    expires_at: Annotated[Optional[int], pydantic.Field(alias="expiresAt")] = None

    original_title: Annotated[Optional[str], pydantic.Field(alias="originalTitle")] = (
        None
    )

    audience_rating: Annotated[
        Optional[float], pydantic.Field(alias="audienceRating")
    ] = None

    audience_rating_image: Annotated[
        Optional[str], pydantic.Field(alias="audienceRatingImage")
    ] = None

    rating_image: Annotated[Optional[str], pydantic.Field(alias="ratingImage")] = None

    imdb_rating_count: Annotated[
        Optional[int], pydantic.Field(alias="imdbRatingCount")
    ] = None

    subtype: Optional[str] = None

    theme: Optional[str] = None

    leaf_count: Annotated[Optional[int], pydantic.Field(alias="leafCount")] = None

    child_count: Annotated[Optional[int], pydantic.Field(alias="childCount")] = None

    is_continuing_series: Annotated[
        Optional[bool], pydantic.Field(alias="isContinuingSeries")
    ] = None

    skip_children: Annotated[Optional[bool], pydantic.Field(alias="skipChildren")] = (
        None
    )

    availability_id: Annotated[
        Optional[str], pydantic.Field(alias="availabilityId")
    ] = None

    streaming_media_id: Annotated[
        Optional[str], pydantic.Field(alias="streamingMediaId")
    ] = None

    playable_key: Annotated[Optional[str], pydantic.Field(alias="playableKey")] = None


class GetWatchListResponseBodyTypedDict(TypedDict):
    r"""Watchlist Data"""

    library_section_id: NotRequired[str]
    library_section_title: NotRequired[str]
    offset: NotRequired[int]
    total_size: NotRequired[int]
    identifier: NotRequired[str]
    size: NotRequired[int]
    metadata: NotRequired[List[MetadataTypedDict]]


class GetWatchListResponseBody(BaseModel):
    r"""Watchlist Data"""

    library_section_id: Annotated[
        Optional[str], pydantic.Field(alias="librarySectionID")
    ] = None

    library_section_title: Annotated[
        Optional[str], pydantic.Field(alias="librarySectionTitle")
    ] = None

    offset: Optional[int] = None

    total_size: Annotated[Optional[int], pydantic.Field(alias="totalSize")] = None

    identifier: Optional[str] = None

    size: Optional[int] = None

    metadata: Annotated[Optional[List[Metadata]], pydantic.Field(alias="Metadata")] = (
        None
    )


class GetWatchListResponseTypedDict(TypedDict):
    content_type: str
    r"""HTTP response content type for this operation"""
    status_code: int
    r"""HTTP response status code for this operation"""
    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""
    object: NotRequired[GetWatchListResponseBodyTypedDict]
    r"""Watchlist Data"""


class GetWatchListResponse(BaseModel):
    content_type: str
    r"""HTTP response content type for this operation"""

    status_code: int
    r"""HTTP response status code for this operation"""

    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""

    object: Optional[GetWatchListResponseBody] = None
    r"""Watchlist Data"""
