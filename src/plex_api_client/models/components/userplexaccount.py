"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .userprofile import UserProfile, UserProfileTypedDict
from enum import Enum
from plex_api_client import utils
from plex_api_client.models import components
from plex_api_client.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from plex_api_client.utils import validate_open_enum
import pydantic
from pydantic import field_serializer, model_serializer
from pydantic.functional_validators import PlainValidator
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class MailingListStatus(str, Enum):
    r"""Your current mailing list status"""

    ACTIVE = "active"
    UNSUBSCRIBED = "unsubscribed"
    REMOVED = "removed"


class UserPlexAccountStatus(str, Enum, metaclass=utils.OpenEnumMeta):
    ONLINE = "online"
    OFFLINE = "offline"


class ServicesTypedDict(TypedDict):
    identifier: str
    endpoint: str
    token: Nullable[str]
    secret: Nullable[str]
    status: UserPlexAccountStatus


class Services(BaseModel):
    identifier: str

    endpoint: str

    token: Nullable[str]

    secret: Nullable[str]

    status: Annotated[UserPlexAccountStatus, PlainValidator(validate_open_enum(False))]

    @field_serializer("status")
    def serialize_status(self, value):
        if isinstance(value, str):
            try:
                return components.UserPlexAccountStatus(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["token", "secret"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UserPlexAccountSubscriptionStatus(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""String representation of subscriptionActive"""

    INACTIVE = "Inactive"
    ACTIVE = "Active"


class SubscriptionTypedDict(TypedDict):
    r"""If the account's Plex Pass subscription is active"""

    features: NotRequired[List[str]]
    r"""List of features allowed on your Plex Pass subscription"""
    active: NotRequired[bool]
    r"""If the account's Plex Pass subscription is active"""
    subscribed_at: NotRequired[Nullable[str]]
    r"""Date the account subscribed to Plex Pass"""
    status: NotRequired[UserPlexAccountSubscriptionStatus]
    r"""String representation of subscriptionActive"""
    payment_service: NotRequired[Nullable[str]]
    r"""Payment service used for your Plex Pass subscription"""
    plan: NotRequired[Nullable[str]]
    r"""Name of Plex Pass subscription plan"""


class Subscription(BaseModel):
    r"""If the account's Plex Pass subscription is active"""

    features: Optional[List[str]] = None
    r"""List of features allowed on your Plex Pass subscription"""

    active: Optional[bool] = None
    r"""If the account's Plex Pass subscription is active"""

    subscribed_at: Annotated[
        OptionalNullable[str], pydantic.Field(alias="subscribedAt")
    ] = UNSET
    r"""Date the account subscribed to Plex Pass"""

    status: Annotated[
        Optional[UserPlexAccountSubscriptionStatus],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""String representation of subscriptionActive"""

    payment_service: Annotated[
        OptionalNullable[str], pydantic.Field(alias="paymentService")
    ] = UNSET
    r"""Payment service used for your Plex Pass subscription"""

    plan: OptionalNullable[str] = UNSET
    r"""Name of Plex Pass subscription plan"""

    @field_serializer("status")
    def serialize_status(self, value):
        if isinstance(value, str):
            try:
                return components.UserPlexAccountSubscriptionStatus(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "features",
            "active",
            "subscribedAt",
            "status",
            "paymentService",
            "plan",
        ]
        nullable_fields = ["subscribedAt", "paymentService", "plan"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UserPlexAccountSubscriptionsStatus(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""String representation of subscriptionActive"""

    INACTIVE = "Inactive"
    ACTIVE = "Active"


class UserPlexAccountSubscriptionTypedDict(TypedDict):
    features: NotRequired[List[str]]
    r"""List of features allowed on your Plex Pass subscription"""
    active: NotRequired[bool]
    r"""If the account's Plex Pass subscription is active"""
    subscribed_at: NotRequired[Nullable[str]]
    r"""Date the account subscribed to Plex Pass"""
    status: NotRequired[UserPlexAccountSubscriptionsStatus]
    r"""String representation of subscriptionActive"""
    payment_service: NotRequired[Nullable[str]]
    r"""Payment service used for your Plex Pass subscription"""
    plan: NotRequired[Nullable[str]]
    r"""Name of Plex Pass subscription plan"""


class UserPlexAccountSubscription(BaseModel):
    features: Optional[List[str]] = None
    r"""List of features allowed on your Plex Pass subscription"""

    active: Optional[bool] = None
    r"""If the account's Plex Pass subscription is active"""

    subscribed_at: Annotated[
        OptionalNullable[str], pydantic.Field(alias="subscribedAt")
    ] = UNSET
    r"""Date the account subscribed to Plex Pass"""

    status: Annotated[
        Optional[UserPlexAccountSubscriptionsStatus],
        PlainValidator(validate_open_enum(False)),
    ] = None
    r"""String representation of subscriptionActive"""

    payment_service: Annotated[
        OptionalNullable[str], pydantic.Field(alias="paymentService")
    ] = UNSET
    r"""Payment service used for your Plex Pass subscription"""

    plan: OptionalNullable[str] = UNSET
    r"""Name of Plex Pass subscription plan"""

    @field_serializer("status")
    def serialize_status(self, value):
        if isinstance(value, str):
            try:
                return components.UserPlexAccountSubscriptionsStatus(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "features",
            "active",
            "subscribedAt",
            "status",
            "paymentService",
            "plan",
        ]
        nullable_fields = ["subscribedAt", "paymentService", "plan"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UserPlexAccountTypedDict(TypedDict):
    auth_token: str
    r"""The account token"""
    email: str
    r"""The account email address"""
    friendly_name: str
    r"""Your account full name"""
    id: int
    r"""The Plex account ID"""
    joined_at: int
    r"""Unix epoch datetime in seconds"""
    title: str
    r"""The title of the account (username or friendly name)"""
    username: str
    r"""The account username"""
    uuid: str
    r"""The account UUID"""
    ads_consent: NotRequired[Nullable[bool]]
    r"""Unknown"""
    ads_consent_reminder_at: NotRequired[Nullable[int]]
    ads_consent_set_at: NotRequired[Nullable[int]]
    anonymous: NotRequired[Nullable[bool]]
    r"""Unknown"""
    backup_codes_created: NotRequired[bool]
    r"""If the two-factor authentication backup codes have been created"""
    confirmed: NotRequired[bool]
    r"""If the account has been confirmed"""
    country: NotRequired[str]
    r"""The account country"""
    email_only_auth: NotRequired[bool]
    r"""If login with email only is enabled"""
    experimental_features: NotRequired[bool]
    r"""If experimental features are enabled"""
    entitlements: NotRequired[List[str]]
    r"""List of devices your allowed to use with this account"""
    guest: NotRequired[bool]
    r"""If the account is a Plex Home guest user"""
    has_password: NotRequired[bool]
    r"""If the account has a password"""
    home: NotRequired[bool]
    r"""If the account is a Plex Home user"""
    home_admin: NotRequired[bool]
    r"""If the account is the Plex Home admin"""
    home_size: NotRequired[int]
    r"""The number of accounts in the Plex Home"""
    locale: NotRequired[Nullable[str]]
    r"""The account locale"""
    mailing_list_active: NotRequired[bool]
    r"""If you are subscribed to the Plex newsletter"""
    mailing_list_status: NotRequired[MailingListStatus]
    r"""Your current mailing list status"""
    max_home_size: NotRequired[int]
    r"""The maximum number of accounts allowed in the Plex Home"""
    pin: NotRequired[str]
    r"""[Might be removed] The hashed Plex Home PIN"""
    profile: NotRequired[UserProfileTypedDict]
    protected: NotRequired[bool]
    r"""If the account has a Plex Home PIN enabled"""
    remember_expires_at: NotRequired[int]
    r"""Unix epoch datetime in seconds"""
    restricted: NotRequired[bool]
    r"""If the account is a Plex Home managed user"""
    roles: NotRequired[List[str]]
    r"""[Might be removed] List of account roles. Plexpass membership listed here"""
    scrobble_types: NotRequired[str]
    r"""Unknown"""
    services: NotRequired[List[ServicesTypedDict]]
    subscription: NotRequired[SubscriptionTypedDict]
    r"""If the account's Plex Pass subscription is active"""
    subscription_description: NotRequired[Nullable[str]]
    r"""Description of the Plex Pass subscription"""
    subscriptions: NotRequired[List[UserPlexAccountSubscriptionTypedDict]]
    thumb: NotRequired[str]
    r"""URL of the account thumbnail"""
    two_factor_enabled: NotRequired[bool]
    r"""If two-factor authentication is enabled"""
    attribution_partner: NotRequired[Nullable[str]]


class UserPlexAccount(BaseModel):
    auth_token: Annotated[str, pydantic.Field(alias="authToken")]
    r"""The account token"""

    email: str
    r"""The account email address"""

    friendly_name: Annotated[str, pydantic.Field(alias="friendlyName")]
    r"""Your account full name"""

    id: int
    r"""The Plex account ID"""

    joined_at: Annotated[int, pydantic.Field(alias="joinedAt")]
    r"""Unix epoch datetime in seconds"""

    title: str
    r"""The title of the account (username or friendly name)"""

    username: str
    r"""The account username"""

    uuid: str
    r"""The account UUID"""

    ads_consent: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="adsConsent")
    ] = UNSET
    r"""Unknown"""

    ads_consent_reminder_at: Annotated[
        OptionalNullable[int], pydantic.Field(alias="adsConsentReminderAt")
    ] = UNSET

    ads_consent_set_at: Annotated[
        OptionalNullable[int], pydantic.Field(alias="adsConsentSetAt")
    ] = UNSET

    anonymous: OptionalNullable[bool] = False
    r"""Unknown"""

    backup_codes_created: Annotated[
        Optional[bool], pydantic.Field(alias="backupCodesCreated")
    ] = False
    r"""If the two-factor authentication backup codes have been created"""

    confirmed: Optional[bool] = False
    r"""If the account has been confirmed"""

    country: Optional[str] = None
    r"""The account country"""

    email_only_auth: Annotated[
        Optional[bool], pydantic.Field(alias="emailOnlyAuth")
    ] = False
    r"""If login with email only is enabled"""

    experimental_features: Annotated[
        Optional[bool], pydantic.Field(alias="experimentalFeatures")
    ] = False
    r"""If experimental features are enabled"""

    entitlements: Optional[List[str]] = None
    r"""List of devices your allowed to use with this account"""

    guest: Optional[bool] = False
    r"""If the account is a Plex Home guest user"""

    has_password: Annotated[Optional[bool], pydantic.Field(alias="hasPassword")] = True
    r"""If the account has a password"""

    home: Optional[bool] = False
    r"""If the account is a Plex Home user"""

    home_admin: Annotated[Optional[bool], pydantic.Field(alias="homeAdmin")] = False
    r"""If the account is the Plex Home admin"""

    home_size: Annotated[Optional[int], pydantic.Field(alias="homeSize")] = None
    r"""The number of accounts in the Plex Home"""

    locale: OptionalNullable[str] = UNSET
    r"""The account locale"""

    mailing_list_active: Annotated[
        Optional[bool], pydantic.Field(alias="mailingListActive")
    ] = False
    r"""If you are subscribed to the Plex newsletter"""

    mailing_list_status: Annotated[
        Optional[MailingListStatus], pydantic.Field(alias="mailingListStatus")
    ] = None
    r"""Your current mailing list status"""

    max_home_size: Annotated[Optional[int], pydantic.Field(alias="maxHomeSize")] = None
    r"""The maximum number of accounts allowed in the Plex Home"""

    pin: Annotated[
        Optional[str],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
        ),
    ] = None
    r"""[Might be removed] The hashed Plex Home PIN"""

    profile: Optional[UserProfile] = None

    protected: Optional[bool] = False
    r"""If the account has a Plex Home PIN enabled"""

    remember_expires_at: Annotated[
        Optional[int], pydantic.Field(alias="rememberExpiresAt")
    ] = None
    r"""Unix epoch datetime in seconds"""

    restricted: Optional[bool] = False
    r"""If the account is a Plex Home managed user"""

    roles: Optional[List[str]] = None
    r"""[Might be removed] List of account roles. Plexpass membership listed here"""

    scrobble_types: Annotated[Optional[str], pydantic.Field(alias="scrobbleTypes")] = (
        None
    )
    r"""Unknown"""

    services: Optional[List[Services]] = None

    subscription: Optional[Subscription] = None
    r"""If the account's Plex Pass subscription is active"""

    subscription_description: Annotated[
        OptionalNullable[str], pydantic.Field(alias="subscriptionDescription")
    ] = UNSET
    r"""Description of the Plex Pass subscription"""

    subscriptions: Optional[List[UserPlexAccountSubscription]] = None

    thumb: Optional[str] = None
    r"""URL of the account thumbnail"""

    two_factor_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="twoFactorEnabled")
    ] = False
    r"""If two-factor authentication is enabled"""

    attribution_partner: Annotated[
        OptionalNullable[str], pydantic.Field(alias="attributionPartner")
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "adsConsent",
            "adsConsentReminderAt",
            "adsConsentSetAt",
            "anonymous",
            "backupCodesCreated",
            "confirmed",
            "country",
            "emailOnlyAuth",
            "experimentalFeatures",
            "entitlements",
            "guest",
            "hasPassword",
            "home",
            "homeAdmin",
            "homeSize",
            "locale",
            "mailingListActive",
            "mailingListStatus",
            "maxHomeSize",
            "pin",
            "profile",
            "protected",
            "rememberExpiresAt",
            "restricted",
            "roles",
            "scrobbleTypes",
            "services",
            "subscription",
            "subscriptionDescription",
            "subscriptions",
            "thumb",
            "twoFactorEnabled",
            "attributionPartner",
        ]
        nullable_fields = [
            "adsConsent",
            "adsConsentReminderAt",
            "adsConsentSetAt",
            "anonymous",
            "locale",
            "subscriptionDescription",
            "attributionPartner",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
